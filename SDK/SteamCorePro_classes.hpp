#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SteamCorePro

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "SteamCorePro_structs.hpp"
#include "SteamCoreShared_structs.hpp"


namespace SDK
{

// Class SteamCorePro.SteamCoreProAsyncAction
// 0x0000 (0x0030 - 0x0030)
class USteamCoreProAsyncAction : public UBlueprintAsyncActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProAsyncAction">();
	}
	static class USteamCoreProAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProAsyncAction>();
	}
};
static_assert(alignof(USteamCoreProAsyncAction) == 0x000008, "Wrong alignment on USteamCoreProAsyncAction");
static_assert(sizeof(USteamCoreProAsyncAction) == 0x000030, "Wrong size on USteamCoreProAsyncAction");

// Class SteamCorePro.SteamCoreProAppsAsyncActionGetFileDetails
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProAppsAsyncActionGetFileDetails final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProAppsAsyncActionGetFileDetails* GetFileDetailsAsync(class UObject* WorldContextObject, const class FString& Filename, float Timeout);

	void HandleCallback(const struct FFileDetailsResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProAppsAsyncActionGetFileDetails">();
	}
	static class USteamCoreProAppsAsyncActionGetFileDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProAppsAsyncActionGetFileDetails>();
	}
};
static_assert(alignof(USteamCoreProAppsAsyncActionGetFileDetails) == 0x000008, "Wrong alignment on USteamCoreProAppsAsyncActionGetFileDetails");
static_assert(sizeof(USteamCoreProAppsAsyncActionGetFileDetails) == 0x000040, "Wrong size on USteamCoreProAppsAsyncActionGetFileDetails");
static_assert(offsetof(USteamCoreProAppsAsyncActionGetFileDetails, OnCallback) == 0x000030, "Member 'USteamCoreProAppsAsyncActionGetFileDetails::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProGameMode
// 0x0000 (0x0380 - 0x0380)
class ASteamCoreProGameMode final : public AGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProGameMode">();
	}
	static class ASteamCoreProGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASteamCoreProGameMode>();
	}
};
static_assert(alignof(ASteamCoreProGameMode) == 0x000008, "Wrong alignment on ASteamCoreProGameMode");
static_assert(sizeof(ASteamCoreProGameMode) == 0x000380, "Wrong size on ASteamCoreProGameMode");

// Class SteamCorePro.SteamCorePro
// 0x0000 (0x0028 - 0x0028)
class USteamCorePro final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCorePro">();
	}
	static class USteamCorePro* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCorePro>();
	}
};
static_assert(alignof(USteamCorePro) == 0x000008, "Wrong alignment on USteamCorePro");
static_assert(sizeof(USteamCorePro) == 0x000028, "Wrong size on USteamCorePro");

// Class SteamCorePro.SteamCoreInterface
// 0x0000 (0x0028 - 0x0028)
class USteamCoreInterface : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreInterface">();
	}
	static class USteamCoreInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreInterface>();
	}
};
static_assert(alignof(USteamCoreInterface) == 0x000008, "Wrong alignment on USteamCoreInterface");
static_assert(sizeof(USteamCoreInterface) == 0x000028, "Wrong size on USteamCoreInterface");

// Class SteamCorePro.SteamCoreProSubsystem
// 0x0020 (0x0048 - 0x0028)
class USteamCoreProSubsystem final : public UObject
{
public:
	uint8                                         Pad_21E9[0x20];                                    // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProSubsystem">();
	}
	static class USteamCoreProSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProSubsystem>();
	}
};
static_assert(alignof(USteamCoreProSubsystem) == 0x000008, "Wrong alignment on USteamCoreProSubsystem");
static_assert(sizeof(USteamCoreProSubsystem) == 0x000048, "Wrong size on USteamCoreProSubsystem");

// Class SteamCorePro.SteamCoreProSettings
// 0x0040 (0x0078 - 0x0038)
class USteamCoreProSettings final : public UDeveloperSettings
{
public:
	bool                                          bEnabled;                                          // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRelaunchInSteam;                                  // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVACEnabled;                                       // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowP2PPacketRelay;                              // 0x003B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCopySteamDlls;                                    // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21EA[0x3];                                     // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         P2PConnectionTimeout;                              // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SteamAppId;                                        // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SteamDevAppId;                                     // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Port;                                              // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameServerQueryPort;                               // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21EB[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameVersion;                                       // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMinHandshakeVersion;                      // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21EC[0x3];                                     // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinHandshakeVersion;                               // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCurrentHandshakeVersion;                  // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21ED[0x3];                                     // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentHandshakeVersion;                           // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProSettings">();
	}
	static class USteamCoreProSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProSettings>();
	}
};
static_assert(alignof(USteamCoreProSettings) == 0x000008, "Wrong alignment on USteamCoreProSettings");
static_assert(sizeof(USteamCoreProSettings) == 0x000078, "Wrong size on USteamCoreProSettings");
static_assert(offsetof(USteamCoreProSettings, bEnabled) == 0x000038, "Member 'USteamCoreProSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(USteamCoreProSettings, bRelaunchInSteam) == 0x000039, "Member 'USteamCoreProSettings::bRelaunchInSteam' has a wrong offset!");
static_assert(offsetof(USteamCoreProSettings, bVACEnabled) == 0x00003A, "Member 'USteamCoreProSettings::bVACEnabled' has a wrong offset!");
static_assert(offsetof(USteamCoreProSettings, bAllowP2PPacketRelay) == 0x00003B, "Member 'USteamCoreProSettings::bAllowP2PPacketRelay' has a wrong offset!");
static_assert(offsetof(USteamCoreProSettings, bCopySteamDlls) == 0x00003C, "Member 'USteamCoreProSettings::bCopySteamDlls' has a wrong offset!");
static_assert(offsetof(USteamCoreProSettings, P2PConnectionTimeout) == 0x000040, "Member 'USteamCoreProSettings::P2PConnectionTimeout' has a wrong offset!");
static_assert(offsetof(USteamCoreProSettings, SteamAppId) == 0x000044, "Member 'USteamCoreProSettings::SteamAppId' has a wrong offset!");
static_assert(offsetof(USteamCoreProSettings, SteamDevAppId) == 0x000048, "Member 'USteamCoreProSettings::SteamDevAppId' has a wrong offset!");
static_assert(offsetof(USteamCoreProSettings, Port) == 0x00004C, "Member 'USteamCoreProSettings::Port' has a wrong offset!");
static_assert(offsetof(USteamCoreProSettings, GameServerQueryPort) == 0x000050, "Member 'USteamCoreProSettings::GameServerQueryPort' has a wrong offset!");
static_assert(offsetof(USteamCoreProSettings, GameVersion) == 0x000058, "Member 'USteamCoreProSettings::GameVersion' has a wrong offset!");
static_assert(offsetof(USteamCoreProSettings, bOverrideMinHandshakeVersion) == 0x000068, "Member 'USteamCoreProSettings::bOverrideMinHandshakeVersion' has a wrong offset!");
static_assert(offsetof(USteamCoreProSettings, MinHandshakeVersion) == 0x00006C, "Member 'USteamCoreProSettings::MinHandshakeVersion' has a wrong offset!");
static_assert(offsetof(USteamCoreProSettings, bOverrideCurrentHandshakeVersion) == 0x000070, "Member 'USteamCoreProSettings::bOverrideCurrentHandshakeVersion' has a wrong offset!");
static_assert(offsetof(USteamCoreProSettings, CurrentHandshakeVersion) == 0x000074, "Member 'USteamCoreProSettings::CurrentHandshakeVersion' has a wrong offset!");

// Class SteamCorePro.SteamProFriends
// 0x0300 (0x0328 - 0x0028)
class USteamProFriends final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             AvatarImageLoaded;                                 // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FriendRichPresenceUpdate;                          // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameConnectedChatJoin;                             // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameConnectedChatLeave;                            // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameConnectedClanChatMsg;                          // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameConnectedFriendChatMsg;                        // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameLobbyJoinRequested;                            // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameOverlayActivated;                              // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameRichPresenceJoinRequested;                     // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameServerChangeRequested;                         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PersonaStateChange;                                // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SetPersonaNameResponse;                            // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             JoinClanChatRoomCompletionResult;                  // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ClanOfficerListResponse;                           // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DownloadClanActivityCountsResult;                  // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EquippedProfileItemsChanged;                       // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_21EE[0x200];                                   // 0x0128(0x0200)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ActivateGameOverlay(const class FString& Dialog);
	static void ActivateGameOverlayInvitedialog(const struct FSteamID& SteamIDLobby);
	static void ActivateGameOverlayInviteDialogConnectString(const class FString& ConnectString);
	static void ActivateGameOverlayToStore(int32 AppID, ESteamOverlayToStoreFlag Flag);
	static void ActivateGameOverlayToUser(const class FString& Dialog, const struct FSteamID& SteamID);
	static void ActivateGameOverlayToWebPage(const class FString& URL, ESteamActivateGameOverlayToWebPageMode Mode);
	static bool BHasEquippedProfileItem(const struct FSteamID& SteamID, ESteamCommunityProfileItemType ItemType);
	static void ClearRichPresence();
	static bool CloseClanChatWindowInSteam(const struct FSteamID& SteamIDClanChat);
	static struct FSteamID GetChatMemberByIndex(const struct FSteamID& SteamIDClan, int32 User);
	static bool GetClanActivityCounts(const struct FSteamID& SteamIDClan, int32* Online, int32* InGame, int32* Chatting);
	static struct FSteamID GetClanByIndex(int32 Clan);
	static int32 GetClanChatMemberCount(const struct FSteamID& SteamIDClan);
	static int32 GetClanChatMessage(const struct FSteamID& SteamIDClanChat, int32 MessageID, class FString* Text, ESteamChatEntryType* ChatEntryType, struct FSteamID* SteamIDChatter);
	static int32 GetClanCount();
	static class FString GetClanName(const struct FSteamID& SteamIDClan);
	static struct FSteamID GetClanOfficerByIndex(const struct FSteamID& SteamIDClan, int32 Officer);
	static int32 GetClanOfficerCount(const struct FSteamID& SteamIDClan);
	static struct FSteamID GetClanOwner(const struct FSteamID& SteamIDClan);
	static class FString GetClanTag(const struct FSteamID& SteamIDClan);
	static struct FSteamID GetCoplayFriend(int32 CoplayFriend);
	static int32 GetCoplayFriendCount();
	static struct FSteamID GetFriendByIndex(int32 Ifriend, const TArray<ESteamFriendFlags>& Param_Flags);
	static int32 GetFriendCoplayGame(const struct FSteamID& SteamIDFriend);
	static int32 GetFriendCoplayTime(const struct FSteamID& SteamIDFriend);
	static int32 GetFriendCount(const TArray<ESteamFriendFlags>& Param_Flags);
	static int32 GetFriendCountFromSource(const struct FSteamID& SteamIDSource);
	static struct FSteamID GetFriendFromSourceByIndex(const struct FSteamID& SteamIDSource, int32 Ifriend);
	static bool GetFriendGamePlayed(const struct FSteamID& SteamIDFriend, struct FSteamGameID* GameId, class FString* GameIP, int32* ConnectionPort, int32* QueryPort, struct FSteamID* SteamIDLobby);
	static int32 GetFriendMessage(const struct FSteamID& SteamIDFriend, int32 MessageID, class FString* Text, ESteamChatEntryType* ChatEntryType);
	static class FString GetFriendPersonaName(const struct FSteamID& SteamIDFriend);
	static class FString GetFriendPersonaNameHistory(const struct FSteamID& SteamIDFriend, int32 PersonaName);
	static ESteamPersonaState GetFriendPersonaState(const struct FSteamID& SteamIDFriend);
	static ESteamFriendRelationship GetFriendRelationship(const struct FSteamID& SteamIDFriend);
	static class FString GetFriendRichPresence(const struct FSteamID& SteamIDFriend, const class FString& Key);
	static class FString GetFriendRichPresenceKeyByIndex(const struct FSteamID& SteamIDFriend, int32 Key);
	static int32 GetFriendRichPresenceKeyCount(const struct FSteamID& SteamIDFriend);
	static int32 GetFriendsGroupCount();
	static struct FSteamFriendsGroupID GetFriendsGroupIDByIndex(int32 FriendGroup);
	static int32 GetFriendsGroupMembersCount(const struct FSteamFriendsGroupID& FriendsGroupID);
	static void GetFriendsGroupMembersList(const struct FSteamFriendsGroupID& FriendsGroupID, TArray<struct FSteamID>* SteamIDMembers, int32 MembersCount);
	static class FString GetFriendsGroupName(const struct FSteamFriendsGroupID& FriendsGroupID);
	static int32 GetFriendSteamLevel(const struct FSteamID& SteamIDFriend);
	static class UTexture2D* GetLargeFriendAvatar(const struct FSteamID& SteamIDFriend);
	static class UTexture2D* GetMediumFriendAvatar(const struct FSteamID& SteamIDFriend);
	static class FString GetPersonaName();
	static class FString GetPersonaName_Pure();
	static ESteamPersonaState GetPersonaState();
	static ESteamPersonaState GetPersonaState_Pure();
	static class FString GetPlayerNickname(const struct FSteamID& SteamIDPlayer);
	static class FString GetPlayerNickname_Pure(const struct FSteamID& SteamIDPlayer);
	static class FString GetProfileItemPropertyString(const struct FSteamID& SteamID, ESteamCommunityProfileItemType ItemType, ESteamCommunityProfileItemProperty Prop);
	static int32 GetProfileItemPropertyUint(const struct FSteamID& SteamID, ESteamCommunityProfileItemType ItemType, ESteamCommunityProfileItemProperty Prop);
	static class UTexture2D* GetSmallFriendAvatar(const struct FSteamID& SteamIDFriend);
	static class USteamProFriends* GetSteamFriends();
	static TArray<ESteamUserRestriction> GetUserRestrictions();
	static bool HasFriend(const struct FSteamID& SteamIDFriend, const TArray<ESteamFriendFlags>& Param_Flags);
	static bool InviteUserToGame(const struct FSteamID& SteamIDFriend, const class FString& ConnectString);
	static bool IsClanChatAdmin(const struct FSteamID& SteamIDClanChat, const struct FSteamID& SteamIDUser);
	static bool IsClanChatWindowOpenInSteam(const struct FSteamID& SteamIDClanChat);
	static bool IsClanOfficialGameGroup(const struct FSteamID& SteamIDClan);
	static bool IsClanPublic(const struct FSteamID& SteamIDClan);
	static bool IsUserInSource(const struct FSteamID& SteamIDUser, const struct FSteamID& SteamIDSource);
	static bool LeaveClanChatRoom(const struct FSteamID& SteamIDClan);
	static bool OpenClanChatWindowInSteam(const struct FSteamID& SteamIDClanChat);
	static bool RegisterProtocolInOverlayBrowser(const class FString& Protocol);
	static bool ReplyToFriendMessage(const struct FSteamID& SteamIDFriend, const class FString& MsgToSend);
	static void RequestFriendRichPresence(const struct FSteamID& SteamIDFriend);
	static bool RequestUserInformation(const struct FSteamID& SteamIDUser, bool bRequireNameOnly);
	static bool SendClanChatMessage(const struct FSteamID& SteamIDClanChat, const class FString& Text);
	static void SetInGameVoiceSpeaking(const struct FSteamID& SteamIDUser, bool bSpeaking);
	static bool SetListenForFriendsMessages(bool bInterceptEnabled);
	static void SetPlayedWith(const struct FSteamID& SteamIDUserPlayedWith);
	static bool SetRichPresence(const class FString& Key, const class FString& Value);

	void DownloadClanActivityCounts(const TDelegate<void(struct FDownloadClanActivityCountsResult& Data, bool bWasSuccessful)>& Callback, const TArray<struct FSteamID>& SteamIDClans);
	void EnumerateFollowingList(const TDelegate<void(struct FFriendsEnumerateFollowingList& Data, bool bWasSuccessful)>& Callback, int32 StartIndex);
	void GetFollowerCount(const TDelegate<void(struct FFriendsGetFollowerCount& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamID);
	void IsFollowing(const TDelegate<void(struct FFriendsIsFollowing& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamID);
	void JoinClanChatRoom(const TDelegate<void(struct FJoinClanChatRoomCompletionResult& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDClan);
	void RequestClanOfficerList(const TDelegate<void(struct FClanOfficerListResponse& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDClan);
	void RequestEquippedProfileItems(const TDelegate<void(struct FEquippedProfileItems& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamID);
	void SetPersonaName(const TDelegate<void(struct FSetPersonaNameResponse& Data, bool bWasSuccessful)>& Callback, const class FString& Param_Name);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProFriends">();
	}
	static class USteamProFriends* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProFriends>();
	}
};
static_assert(alignof(USteamProFriends) == 0x000008, "Wrong alignment on USteamProFriends");
static_assert(sizeof(USteamProFriends) == 0x000328, "Wrong size on USteamProFriends");
static_assert(offsetof(USteamProFriends, AvatarImageLoaded) == 0x000028, "Member 'USteamProFriends::AvatarImageLoaded' has a wrong offset!");
static_assert(offsetof(USteamProFriends, FriendRichPresenceUpdate) == 0x000038, "Member 'USteamProFriends::FriendRichPresenceUpdate' has a wrong offset!");
static_assert(offsetof(USteamProFriends, GameConnectedChatJoin) == 0x000048, "Member 'USteamProFriends::GameConnectedChatJoin' has a wrong offset!");
static_assert(offsetof(USteamProFriends, GameConnectedChatLeave) == 0x000058, "Member 'USteamProFriends::GameConnectedChatLeave' has a wrong offset!");
static_assert(offsetof(USteamProFriends, GameConnectedClanChatMsg) == 0x000068, "Member 'USteamProFriends::GameConnectedClanChatMsg' has a wrong offset!");
static_assert(offsetof(USteamProFriends, GameConnectedFriendChatMsg) == 0x000078, "Member 'USteamProFriends::GameConnectedFriendChatMsg' has a wrong offset!");
static_assert(offsetof(USteamProFriends, GameLobbyJoinRequested) == 0x000088, "Member 'USteamProFriends::GameLobbyJoinRequested' has a wrong offset!");
static_assert(offsetof(USteamProFriends, GameOverlayActivated) == 0x000098, "Member 'USteamProFriends::GameOverlayActivated' has a wrong offset!");
static_assert(offsetof(USteamProFriends, GameRichPresenceJoinRequested) == 0x0000A8, "Member 'USteamProFriends::GameRichPresenceJoinRequested' has a wrong offset!");
static_assert(offsetof(USteamProFriends, GameServerChangeRequested) == 0x0000B8, "Member 'USteamProFriends::GameServerChangeRequested' has a wrong offset!");
static_assert(offsetof(USteamProFriends, PersonaStateChange) == 0x0000C8, "Member 'USteamProFriends::PersonaStateChange' has a wrong offset!");
static_assert(offsetof(USteamProFriends, SetPersonaNameResponse) == 0x0000D8, "Member 'USteamProFriends::SetPersonaNameResponse' has a wrong offset!");
static_assert(offsetof(USteamProFriends, JoinClanChatRoomCompletionResult) == 0x0000E8, "Member 'USteamProFriends::JoinClanChatRoomCompletionResult' has a wrong offset!");
static_assert(offsetof(USteamProFriends, ClanOfficerListResponse) == 0x0000F8, "Member 'USteamProFriends::ClanOfficerListResponse' has a wrong offset!");
static_assert(offsetof(USteamProFriends, DownloadClanActivityCountsResult) == 0x000108, "Member 'USteamProFriends::DownloadClanActivityCountsResult' has a wrong offset!");
static_assert(offsetof(USteamProFriends, EquippedProfileItemsChanged) == 0x000118, "Member 'USteamProFriends::EquippedProfileItemsChanged' has a wrong offset!");

// Class SteamCorePro.SteamCoreProFriendsAsyncActionSetPersonaName
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProFriendsAsyncActionSetPersonaName final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProFriendsAsyncActionSetPersonaName* SetPersonaNameAsync(class UObject* WorldContextObject, const class FString& Param_Name, float Timeout);

	void HandleCallback(const struct FSetPersonaNameResponse& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProFriendsAsyncActionSetPersonaName">();
	}
	static class USteamCoreProFriendsAsyncActionSetPersonaName* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProFriendsAsyncActionSetPersonaName>();
	}
};
static_assert(alignof(USteamCoreProFriendsAsyncActionSetPersonaName) == 0x000008, "Wrong alignment on USteamCoreProFriendsAsyncActionSetPersonaName");
static_assert(sizeof(USteamCoreProFriendsAsyncActionSetPersonaName) == 0x000040, "Wrong size on USteamCoreProFriendsAsyncActionSetPersonaName");
static_assert(offsetof(USteamCoreProFriendsAsyncActionSetPersonaName, OnCallback) == 0x000030, "Member 'USteamCoreProFriendsAsyncActionSetPersonaName::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProFriendsAsyncActionDownloadClanActivityCounts
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProFriendsAsyncActionDownloadClanActivityCounts final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProFriendsAsyncActionDownloadClanActivityCounts* DownloadClanActivityCountsAsync(class UObject* WorldContextObject, const TArray<struct FSteamID>& SteamIDClans, float Timeout);

	void HandleCallback(const struct FDownloadClanActivityCountsResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProFriendsAsyncActionDownloadClanActivityCounts">();
	}
	static class USteamCoreProFriendsAsyncActionDownloadClanActivityCounts* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProFriendsAsyncActionDownloadClanActivityCounts>();
	}
};
static_assert(alignof(USteamCoreProFriendsAsyncActionDownloadClanActivityCounts) == 0x000008, "Wrong alignment on USteamCoreProFriendsAsyncActionDownloadClanActivityCounts");
static_assert(sizeof(USteamCoreProFriendsAsyncActionDownloadClanActivityCounts) == 0x000040, "Wrong size on USteamCoreProFriendsAsyncActionDownloadClanActivityCounts");
static_assert(offsetof(USteamCoreProFriendsAsyncActionDownloadClanActivityCounts, OnCallback) == 0x000030, "Member 'USteamCoreProFriendsAsyncActionDownloadClanActivityCounts::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProFriendsAsyncActionRequestClanOfficerList
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProFriendsAsyncActionRequestClanOfficerList final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProFriendsAsyncActionRequestClanOfficerList* RequestClanOfficerListAsync(class UObject* WorldContextObject, const struct FSteamID& SteamIDClan, float Timeout);

	void HandleCallback(const struct FClanOfficerListResponse& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProFriendsAsyncActionRequestClanOfficerList">();
	}
	static class USteamCoreProFriendsAsyncActionRequestClanOfficerList* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProFriendsAsyncActionRequestClanOfficerList>();
	}
};
static_assert(alignof(USteamCoreProFriendsAsyncActionRequestClanOfficerList) == 0x000008, "Wrong alignment on USteamCoreProFriendsAsyncActionRequestClanOfficerList");
static_assert(sizeof(USteamCoreProFriendsAsyncActionRequestClanOfficerList) == 0x000040, "Wrong size on USteamCoreProFriendsAsyncActionRequestClanOfficerList");
static_assert(offsetof(USteamCoreProFriendsAsyncActionRequestClanOfficerList, OnCallback) == 0x000030, "Member 'USteamCoreProFriendsAsyncActionRequestClanOfficerList::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProFriendsAsyncActionJoinClanChatRoom
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProFriendsAsyncActionJoinClanChatRoom final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProFriendsAsyncActionJoinClanChatRoom* JoinClanChatRoomAsync(class UObject* WorldContextObject, const struct FSteamID& SteamIDClan, float Timeout);

	void HandleCallback(const struct FJoinClanChatRoomCompletionResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProFriendsAsyncActionJoinClanChatRoom">();
	}
	static class USteamCoreProFriendsAsyncActionJoinClanChatRoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProFriendsAsyncActionJoinClanChatRoom>();
	}
};
static_assert(alignof(USteamCoreProFriendsAsyncActionJoinClanChatRoom) == 0x000008, "Wrong alignment on USteamCoreProFriendsAsyncActionJoinClanChatRoom");
static_assert(sizeof(USteamCoreProFriendsAsyncActionJoinClanChatRoom) == 0x000040, "Wrong size on USteamCoreProFriendsAsyncActionJoinClanChatRoom");
static_assert(offsetof(USteamCoreProFriendsAsyncActionJoinClanChatRoom, OnCallback) == 0x000030, "Member 'USteamCoreProFriendsAsyncActionJoinClanChatRoom::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProFriendsAsyncActionEnumerateFollowingList
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProFriendsAsyncActionEnumerateFollowingList final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProFriendsAsyncActionEnumerateFollowingList* EnumerateFollowingListAsync(class UObject* WorldContextObject, int32 StartIndex, float Timeout);

	void HandleCallback(const struct FFriendsEnumerateFollowingList& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProFriendsAsyncActionEnumerateFollowingList">();
	}
	static class USteamCoreProFriendsAsyncActionEnumerateFollowingList* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProFriendsAsyncActionEnumerateFollowingList>();
	}
};
static_assert(alignof(USteamCoreProFriendsAsyncActionEnumerateFollowingList) == 0x000008, "Wrong alignment on USteamCoreProFriendsAsyncActionEnumerateFollowingList");
static_assert(sizeof(USteamCoreProFriendsAsyncActionEnumerateFollowingList) == 0x000040, "Wrong size on USteamCoreProFriendsAsyncActionEnumerateFollowingList");
static_assert(offsetof(USteamCoreProFriendsAsyncActionEnumerateFollowingList, OnCallback) == 0x000030, "Member 'USteamCoreProFriendsAsyncActionEnumerateFollowingList::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProFriendsAsyncActionIsFollowing
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProFriendsAsyncActionIsFollowing final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProFriendsAsyncActionIsFollowing* IsFollowingAsync(class UObject* WorldContextObject, const struct FSteamID& SteamID, float Timeout);

	void HandleCallback(const struct FFriendsIsFollowing& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProFriendsAsyncActionIsFollowing">();
	}
	static class USteamCoreProFriendsAsyncActionIsFollowing* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProFriendsAsyncActionIsFollowing>();
	}
};
static_assert(alignof(USteamCoreProFriendsAsyncActionIsFollowing) == 0x000008, "Wrong alignment on USteamCoreProFriendsAsyncActionIsFollowing");
static_assert(sizeof(USteamCoreProFriendsAsyncActionIsFollowing) == 0x000040, "Wrong size on USteamCoreProFriendsAsyncActionIsFollowing");
static_assert(offsetof(USteamCoreProFriendsAsyncActionIsFollowing, OnCallback) == 0x000030, "Member 'USteamCoreProFriendsAsyncActionIsFollowing::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProFriendsAsyncActionGetFollowerCount
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProFriendsAsyncActionGetFollowerCount final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProFriendsAsyncActionGetFollowerCount* GetFollowerCountAsync(class UObject* WorldContextObject, const struct FSteamID& SteamID, float Timeout);

	void HandleCallback(const struct FFriendsGetFollowerCount& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProFriendsAsyncActionGetFollowerCount">();
	}
	static class USteamCoreProFriendsAsyncActionGetFollowerCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProFriendsAsyncActionGetFollowerCount>();
	}
};
static_assert(alignof(USteamCoreProFriendsAsyncActionGetFollowerCount) == 0x000008, "Wrong alignment on USteamCoreProFriendsAsyncActionGetFollowerCount");
static_assert(sizeof(USteamCoreProFriendsAsyncActionGetFollowerCount) == 0x000040, "Wrong size on USteamCoreProFriendsAsyncActionGetFollowerCount");
static_assert(offsetof(USteamCoreProFriendsAsyncActionGetFollowerCount, OnCallback) == 0x000030, "Member 'USteamCoreProFriendsAsyncActionGetFollowerCount::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProFriendsAsyncActionRequestUserInformation
// 0x0040 (0x0070 - 0x0030)
class USteamCoreProFriendsAsyncActionRequestUserInformation final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_222D[0x30];                                    // 0x0040(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamCoreProFriendsAsyncActionRequestUserInformation* RequestUserInformationAsync(class UObject* WorldContextObject, const struct FSteamID& SteamIDUser, bool bRequireNameOnly, float Timeout);

	void HandleCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProFriendsAsyncActionRequestUserInformation">();
	}
	static class USteamCoreProFriendsAsyncActionRequestUserInformation* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProFriendsAsyncActionRequestUserInformation>();
	}
};
static_assert(alignof(USteamCoreProFriendsAsyncActionRequestUserInformation) == 0x000008, "Wrong alignment on USteamCoreProFriendsAsyncActionRequestUserInformation");
static_assert(sizeof(USteamCoreProFriendsAsyncActionRequestUserInformation) == 0x000070, "Wrong size on USteamCoreProFriendsAsyncActionRequestUserInformation");
static_assert(offsetof(USteamCoreProFriendsAsyncActionRequestUserInformation, OnCallback) == 0x000030, "Member 'USteamCoreProFriendsAsyncActionRequestUserInformation::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamProGameServerStats
// 0x0030 (0x0058 - 0x0028)
class USteamProGameServerStats final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             GSStatsUnloaded;                                   // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_222F[0x20];                                    // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamProGameServerStats* GetSteamGameServerStats();

	bool ClearUserAchievement(const struct FSteamID& SteamIDUser, const class FString& Param_Name);
	bool GetUserAchievement(const struct FSteamID& SteamIDUser, const class FString& Param_Name, bool* bAchieved);
	bool GetUserStatFloat(const struct FSteamID& SteamIDUser, const class FString& Param_Name, float* Data);
	bool GetUserStatInt(const struct FSteamID& SteamIDUser, const class FString& Param_Name, int32* Data);
	void ServerRequestUserStats(const TDelegate<void(struct FGSStatsReceived& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDUser);
	void ServerStoreUserStats(const TDelegate<void(struct FGSStatsStored& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDUser);
	bool SetUserAchievement(const struct FSteamID& SteamIDUser, const class FString& Param_Name);
	bool SetUserStatFloat(const struct FSteamID& SteamIDUser, const class FString& Param_Name, float Data);
	bool SetUserStatInt(const struct FSteamID& SteamIDUser, const class FString& Param_Name, int32 Data);
	bool UpdateUserAvgRateStat(const struct FSteamID& SteamIDUser, const class FString& Param_Name, float CountThisSession, float SessionLength);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProGameServerStats">();
	}
	static class USteamProGameServerStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProGameServerStats>();
	}
};
static_assert(alignof(USteamProGameServerStats) == 0x000008, "Wrong alignment on USteamProGameServerStats");
static_assert(sizeof(USteamProGameServerStats) == 0x000058, "Wrong size on USteamProGameServerStats");
static_assert(offsetof(USteamProGameServerStats, GSStatsUnloaded) == 0x000028, "Member 'USteamProGameServerStats::GSStatsUnloaded' has a wrong offset!");

// Class SteamCorePro.SteamProInput
// 0x0000 (0x0028 - 0x0028)
class USteamProInput final : public USteamCoreInterface
{
public:
	static bool BNewDataAvailable();
	static bool BWaitForData(bool bWaitForever, int32 Timeout);
	static TArray<ESteamCoreInputConfigurationEnableType> GetSessionInputConfigurationSettings();
	static class USteamProInput* GetSteamInput();
	static class FString GetStringForAnalogActionName(const struct FInputAnalogActionHandle& ActionHandle);
	static class FString GetStringForDigitalActionName(const struct FInputDigitalActionHandle& ActionHandle);
	static void SetDualSenseTriggerEffect(const struct FInputHandle& InputHandle, const struct FScePadTriggerEffectCommand& R2, const struct FScePadTriggerEffectCommand& L2);

	void ActivateActionSet(const struct FInputHandle& Handle, const struct FInputActionSetHandle& ActionSetHandle);
	void ActivateActionSetLayer(const struct FInputHandle& Handle, const struct FInputActionSetHandle& ActionSetLayerHandle);
	void DeactivateActionSetLayer(const struct FInputHandle& Handle, const struct FInputActionSetHandle& ActionSetLayerHandle);
	void DeactivateAllActionSetLayers(const struct FInputHandle& Handle);
	ESteamCoreProInputActionOrigin GetActionOriginFromXboxOrigin(const struct FInputHandle& Handle, ESteamCoreProXboxOrigin Origin);
	struct FInputActionSetHandle GetActionSetHandle(const class FString& ActionSetName);
	int32 GetActiveActionSetLayers(const struct FInputHandle& Handle, TArray<struct FInputActionSetHandle>* Data);
	struct FInputAnalogActionData GetAnalogActionData(const struct FInputHandle& Handle, const struct FInputAnalogActionHandle& AnalogActionHandle);
	struct FInputAnalogActionHandle GetAnalogActionHandle(const class FString& PszActionName);
	int32 GetAnalogActionOrigins(const struct FInputHandle& Handle, const struct FInputActionSetHandle& ActionSetHandle, const struct FInputAnalogActionHandle& AnalogActionHandle, TArray<ESteamCoreProInputActionOrigin>* OriginsOut);
	int32 GetConnectedControllers(TArray<struct FInputHandle>* OutHandles);
	struct FInputHandle GetControllerForGamepadIndex(int32 Param_Index);
	struct FInputActionSetHandle GetCurrentActionSet(const struct FInputHandle& Handle);
	bool GetDeviceBindingRevision(const struct FInputHandle& Handle, int32* Major, int32* Minor);
	struct FInputDigitalActionData GetDigitalActionData(const struct FInputHandle& Handle, const struct FInputDigitalActionHandle& DigitalActionHandle);
	struct FInputDigitalActionHandle GetDigitalActionHandle(const class FString& PszActionName);
	int32 GetDigitalActionOrigins(const struct FInputHandle& Handle, const struct FInputActionSetHandle& ActionSetHandle, const struct FInputDigitalActionHandle& DigitalActionHandle, TArray<ESteamCoreProInputActionOrigin>* OriginsOut);
	int32 GetGamepadIndexForController(const struct FInputHandle& Handle);
	class FString GetGlyphForActionOrigin_Legacy(ESteamCoreProInputActionOrigin Origin);
	class FString GetGlyphForXboxOrigin(ESteamCoreProXboxOrigin Origin);
	ESteamCoreProInputType GetInputTypeForHandle(const struct FInputHandle& Handle);
	struct FInputMotionData GetMotionData(const struct FInputHandle& Handle);
	int32 GetRemotePlaySessionID(const struct FInputHandle& Handle);
	class FString GetStringForActionOrigin(ESteamCoreProInputActionOrigin Origin);
	class FString GetStringForXboxOrigin(ESteamCoreProXboxOrigin Origin);
	bool Init();
	void Legacy_TriggerHapticPulse(const struct FInputHandle& Handle, ESteamCoreProControllerPad TargetPad, uint8 DurationMicroSec);
	void Legacy_TriggerRepeatedHapticPulse(const struct FInputHandle& Handle, ESteamCoreProControllerPad TargetPad, uint8 DurationMicroSec, uint8 OffMicroSec, uint8 Repeat, uint8 Param_Flags);
	void SetLEDColor(const struct FInputHandle& Handle, uint8 ColorR, uint8 ColorG, uint8 ColorB, ESteamCoreProInputLEDFlag Param_Flags);
	bool ShowBindingPanel(const struct FInputHandle& Handle);
	bool Shutdown();
	void StopAnalogActionMomentum(const struct FInputHandle& Handle, const struct FInputAnalogActionHandle& EAction);
	ESteamCoreProInputActionOrigin TranslateActionOrigin(ESteamCoreProInputType DestinationInputType, ESteamCoreProInputActionOrigin SourceOrigin);
	void TriggerVibration(const struct FInputHandle& Handle, uint8 LeftSpeed, uint8 RightSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProInput">();
	}
	static class USteamProInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProInput>();
	}
};
static_assert(alignof(USteamProInput) == 0x000008, "Wrong alignment on USteamProInput");
static_assert(sizeof(USteamProInput) == 0x000028, "Wrong size on USteamProInput");

// Class SteamCorePro.SteamProInventory
// 0x0120 (0x0148 - 0x0028)
class USteamProInventory final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             SteamInventoryResultReady;                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamInventoryDefinitionUpdate;                    // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamInventoryFullUpdate;                          // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamInventoryStartPurchaseResult;                 // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamInventoryRequestPricesResultDelegate;         // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamInventoryEligiblePromoItemDefIDs;             // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_224E[0xC0];                                    // 0x0088(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool AddPromoItem(struct FSteamInventoryResult* Result, const struct FSteamItemDef& ItemDef);
	static bool AddPromoItems(struct FSteamInventoryResult* OutResult, const TArray<struct FSteamItemDef>& ItemDefs);
	static bool CheckResultSteamID(const struct FSteamInventoryResult& Handle, const struct FSteamID& SteamIDExpected);
	static bool ConsumeItem(struct FSteamInventoryResult* Result, const struct FSteamItemInstanceID& ItemConsume, int32 Quantity);
	static bool DeserializeResult(struct FSteamInventoryResult* Result, const TArray<uint8>& Buffer, bool bReservedMustBeFalse);
	static void DestroyResult(const struct FSteamInventoryResult& Handle);
	static bool ExchangeItems(struct FSteamInventoryResult* Result, const TArray<struct FSteamItemDef>& ArrayGenerate, const TArray<int32>& ArrayGenerateQuantity, const TArray<struct FSteamItemInstanceID>& ArrayDestroy, const TArray<int32>& ArrayDestroyQuantity);
	static bool GenerateItems(struct FSteamInventoryResult* Result, const TArray<struct FSteamItemDef>& ItemDefs, const TArray<int32>& Quantity);
	static bool GetAllItems(struct FSteamInventoryResult* Handle);
	static bool GetEligiblePromoItemDefinitionIDs(const struct FSteamID& SteamID, TArray<struct FSteamItemDef>* ItemDefs);
	static bool GetItemDefinitionIDs(TArray<struct FSteamItemDef>* ItemDefs);
	static bool GetItemDefinitionProperty(const struct FSteamItemDef& ItemDef, const class FString& PropertyName, class FString* Value);
	static bool GetItemPrice(const struct FSteamItemDef& ItemDef, int32* Price, int32* BasePrice);
	static bool GetItemsByID(struct FSteamInventoryResult* InventoryResult, const TArray<struct FSteamItemInstanceID>& InstanceIDs);
	static bool GetItemsWithPrices(TArray<struct FSteamItemDef>* ItemDefs, TArray<int32>* Prices, TArray<int32>* BasePrices);
	static int32 GetNumItemsWithPrices();
	static bool GetResultItemProperty(const struct FSteamInventoryResult& Handle, int32 ItemIndex, const class FString& PropertyName, class FString* Value);
	static bool GetResultItems(const struct FSteamInventoryResult& Handle, TArray<struct FSteamItemDetails>* Items);
	static ESteamResult GetResultStatus(const struct FSteamInventoryResult& Handle);
	static int32 GetResultTimestamp(const struct FSteamInventoryResult& Handle);
	static class USteamProInventory* GetSteamInventory();
	static bool GrantPromoItems(struct FSteamInventoryResult* Result);
	static bool LoadItemDefinitions();
	static bool RemoveProperty(const struct FSteamInventoryUpdateHandle& Handle, const struct FSteamItemInstanceID& ItemId, const class FString& PropertyName);
	static bool SerializeResult(const struct FSteamInventoryResult& Handle, TArray<uint8>* Buffer);
	static bool SetPropertyBool(const struct FSteamInventoryUpdateHandle& Handle, const struct FSteamItemInstanceID& ItemId, const class FString& PropertyName, bool bValue);
	static bool SetPropertyFloat(const struct FSteamInventoryUpdateHandle& Handle, const struct FSteamItemInstanceID& ItemId, const class FString& PropertyName, float Value);
	static bool SetPropertyInt(const struct FSteamInventoryUpdateHandle& Handle, const struct FSteamItemInstanceID& ItemId, const class FString& PropertyName, int32 Value);
	static bool SetPropertyString(const struct FSteamInventoryUpdateHandle& Handle, const struct FSteamItemInstanceID& ItemId, const class FString& PropertyName, const class FString& Value);
	static struct FSteamInventoryUpdateHandle StartUpdateProperties();
	static bool SubmitUpdateProperties(const struct FSteamInventoryUpdateHandle& Handle, struct FSteamInventoryResult* ResultHandle);
	static bool TransferItemQuantity(struct FSteamInventoryResult* Result, const struct FSteamItemInstanceID& ItemIDSource, int32 Quantity, const struct FSteamItemInstanceID& ItemIDDest);
	static bool TriggerItemDrop(struct FSteamInventoryResult* Result, const struct FSteamItemDef& ListDefinition);

	void RequestEligiblePromoItemDefinitionsIDs(const TDelegate<void(struct FSteamInventoryEligiblePromoItemDefIDs& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamID);
	void RequestPrices(const TDelegate<void(struct FSteamInventoryRequestPricesResult& Data, bool bWasSuccessful)>& Callback);
	void StartPurchase(const TDelegate<void(struct FSteamInventoryStartPurchaseResult& Data, bool bWasSuccessful)>& Callback, const TArray<struct FSteamItemDef>& ItemDefs, const TArray<int32>& Quantity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProInventory">();
	}
	static class USteamProInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProInventory>();
	}
};
static_assert(alignof(USteamProInventory) == 0x000008, "Wrong alignment on USteamProInventory");
static_assert(sizeof(USteamProInventory) == 0x000148, "Wrong size on USteamProInventory");
static_assert(offsetof(USteamProInventory, SteamInventoryResultReady) == 0x000028, "Member 'USteamProInventory::SteamInventoryResultReady' has a wrong offset!");
static_assert(offsetof(USteamProInventory, SteamInventoryDefinitionUpdate) == 0x000038, "Member 'USteamProInventory::SteamInventoryDefinitionUpdate' has a wrong offset!");
static_assert(offsetof(USteamProInventory, SteamInventoryFullUpdate) == 0x000048, "Member 'USteamProInventory::SteamInventoryFullUpdate' has a wrong offset!");
static_assert(offsetof(USteamProInventory, SteamInventoryStartPurchaseResult) == 0x000058, "Member 'USteamProInventory::SteamInventoryStartPurchaseResult' has a wrong offset!");
static_assert(offsetof(USteamProInventory, SteamInventoryRequestPricesResultDelegate) == 0x000068, "Member 'USteamProInventory::SteamInventoryRequestPricesResultDelegate' has a wrong offset!");
static_assert(offsetof(USteamProInventory, SteamInventoryEligiblePromoItemDefIDs) == 0x000078, "Member 'USteamProInventory::SteamInventoryEligiblePromoItemDefIDs' has a wrong offset!");

// Class SteamCorePro.SteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs* RequestEligiblePromoItemDefinitionsIDsAsync(class UObject* WorldContextObject, const struct FSteamID& SteamID, float Timeout);

	void HandleCallback(const struct FSteamInventoryEligiblePromoItemDefIDs& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs">();
	}
	static class USteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs>();
	}
};
static_assert(alignof(USteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs) == 0x000008, "Wrong alignment on USteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs");
static_assert(sizeof(USteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs) == 0x000040, "Wrong size on USteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs");
static_assert(offsetof(USteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs, OnCallback) == 0x000030, "Member 'USteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProInventoryAsyncActionRequestPricesResult
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProInventoryAsyncActionRequestPricesResult final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProInventoryAsyncActionRequestPricesResult* RequestPricesAsync(class UObject* WorldContextObject, float Timeout);

	void HandleCallback(const struct FSteamInventoryRequestPricesResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProInventoryAsyncActionRequestPricesResult">();
	}
	static class USteamCoreProInventoryAsyncActionRequestPricesResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProInventoryAsyncActionRequestPricesResult>();
	}
};
static_assert(alignof(USteamCoreProInventoryAsyncActionRequestPricesResult) == 0x000008, "Wrong alignment on USteamCoreProInventoryAsyncActionRequestPricesResult");
static_assert(sizeof(USteamCoreProInventoryAsyncActionRequestPricesResult) == 0x000040, "Wrong size on USteamCoreProInventoryAsyncActionRequestPricesResult");
static_assert(offsetof(USteamCoreProInventoryAsyncActionRequestPricesResult, OnCallback) == 0x000030, "Member 'USteamCoreProInventoryAsyncActionRequestPricesResult::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProInventoryAsyncActionStartPurchaseResult
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProInventoryAsyncActionStartPurchaseResult final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProInventoryAsyncActionStartPurchaseResult* StartPurchaseAsync(class UObject* WorldContextObject, const TArray<struct FSteamItemDef>& ItemDefs, const TArray<int32>& Quantity, float Timeout);

	void HandleCallback(const struct FSteamInventoryStartPurchaseResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProInventoryAsyncActionStartPurchaseResult">();
	}
	static class USteamCoreProInventoryAsyncActionStartPurchaseResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProInventoryAsyncActionStartPurchaseResult>();
	}
};
static_assert(alignof(USteamCoreProInventoryAsyncActionStartPurchaseResult) == 0x000008, "Wrong alignment on USteamCoreProInventoryAsyncActionStartPurchaseResult");
static_assert(sizeof(USteamCoreProInventoryAsyncActionStartPurchaseResult) == 0x000040, "Wrong size on USteamCoreProInventoryAsyncActionStartPurchaseResult");
static_assert(offsetof(USteamCoreProInventoryAsyncActionStartPurchaseResult, OnCallback) == 0x000030, "Member 'USteamCoreProInventoryAsyncActionStartPurchaseResult::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamProMatchmaking
// 0x01B0 (0x01D8 - 0x0028)
class USteamProMatchmaking final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             FavoritesListAccountsUpdated;                      // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FavoritesListChanged;                              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LobbyChatMsg;                                      // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LobbyChatUpdate;                                   // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LobbyDataUpdate;                                   // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LobbyEnter;                                        // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LobbyGameCreated;                                  // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LobbyInvite;                                       // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LobbyKicked;                                       // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_227C[0x120];                                   // 0x00B8(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 AddFavoriteGame(int32 AppID, const class FString& IP, int32 ConnectionPort, int32 QueryPort, const TArray<ESteamFavoriteFlags>& Param_Flags, int32 TimeLastPlayedOnServer);
	static void AddRequestLobbyListCompatibleMembersFilter(const struct FSteamID& SteamIDLobby);
	static void AddRequestLobbyListDistanceFilter(ESteamLobbyDistanceFilter LobbyDistanceFilter);
	static void AddRequestLobbyListFilterSlotsAvailable(int32 SlotsAvailable);
	static void AddRequestLobbyListNearValueFilter(const class FString& KeyToMatch, int32 ValueToBeCloseTo);
	static void AddRequestLobbyListNumericalFilter(const class FString& KeyToMatch, int32 ValueToMatch, ESteamLobbyComparison ComparisonType);
	static void AddRequestLobbyListResultCountFilter(int32 MaxResults);
	static void AddRequestLobbyListStringFilter(const class FString& KeyToMatch, const class FString& ValueToMatch, ESteamLobbyComparison ComparisonType);
	static bool DeleteLobbyData(const struct FSteamID& SteamIDLobby, const class FString& Key);
	static bool GetFavoriteGame(int32 Game, int32* AppID, class FString* IP, int32* ConnectionPort, int32* QueryPort, TArray<ESteamFavoriteFlags>* Param_Flags, int32* TimeLastPlayedOnServer);
	static int32 GetFavoriteGameCount();
	static struct FSteamID GetLobbyByIndex(int32 Lobby);
	static int32 GetLobbyChatEntry(const struct FSteamID& SteamIDLobby, int32 MessageID, struct FSteamID* SteamIDUser, class FString* Message, ESteamChatEntryType* ChatEntryType);
	static class FString GetLobbyData(const struct FSteamID& SteamIDLobby, const class FString& Key);
	static bool GetLobbyDataByIndex(const struct FSteamID& SteamIDLobby, int32 LobbyData, class FString* Key, class FString* Value);
	static int32 GetLobbyDataCount(const struct FSteamID& SteamIDLobby);
	static bool GetLobbyGameServer(const struct FSteamID& SteamIDLobby, class FString* GameServerIP, int32* GameServerPort, struct FSteamID* SteamIDGameServer);
	static struct FSteamID GetLobbyMemberByIndex(const struct FSteamID& SteamIDLobby, int32 Member);
	static class FString GetLobbyMemberData(const struct FSteamID& SteamIDLobby, const struct FSteamID& SteamIDUser, const class FString& Key);
	static int32 GetLobbyMemberLimit(const struct FSteamID& SteamIDLobby);
	static struct FSteamID GetLobbyOwner(const struct FSteamID& SteamIDLobby);
	static int32 GetNumLobbyMembers(const struct FSteamID& SteamIDLobby);
	static class USteamProMatchmaking* GetSteamMatchmaking();
	static bool InviteUserToLobby(const struct FSteamID& SteamIDLobby, const struct FSteamID& SteamIDInvitee);
	static void LeaveLobby(const struct FSteamID& SteamIDLobby);
	static bool RemoveFavoriteGame(int32 AppID, const class FString& IP, int32 ConnectionPort, int32 QueryPort, const TArray<ESteamFavoriteFlags>& Param_Flags);
	static bool RequestLobbyData(const struct FSteamID& SteamIDLobby);
	static bool SendLobbyChatMsg(const struct FSteamID& SteamIDLobby, const class FString& Message);
	static bool SetLinkedLobby(const struct FSteamID& SteamIDLobby, const struct FSteamID& SteamIDLobbyDependent);
	static bool SetLobbyData(const struct FSteamID& SteamIDLobby, const class FString& Key, const class FString& Value);
	static void SetLobbyGameServer(const struct FSteamID& SteamIDLobby, const class FString& GameServerIP, int32 GameServerPort, const struct FSteamID& SteamIDGameServer);
	static bool SetLobbyJoinable(const struct FSteamID& SteamIDLobby, bool bLobbyJoinable);
	static void SetLobbyMemberData(const struct FSteamID& SteamIDLobby, const class FString& Key, const class FString& Value);
	static bool SetLobbyMemberLimit(const struct FSteamID& SteamIDLobby, int32 MaxMembers);
	static bool SetLobbyOwner(const struct FSteamID& SteamIDLobby, const struct FSteamID& SteamIDNewOwner);
	static bool SetLobbyType(const struct FSteamID& SteamIDLobby, ESteamLobbyType LobbyType);

	void CreateLobby(const TDelegate<void(struct FCreateLobbyData& Data, bool bWasSuccessful)>& Callback, ESteamLobbyType LobbyType, int32 MaxMembers);
	void JoinLobby(const TDelegate<void(struct FJoinLobbyData& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDLobby);
	void RequestLobbyList(const TDelegate<void(struct FLobbyMatchList& Data, bool bWasSuccessful)>& Callback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProMatchmaking">();
	}
	static class USteamProMatchmaking* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProMatchmaking>();
	}
};
static_assert(alignof(USteamProMatchmaking) == 0x000008, "Wrong alignment on USteamProMatchmaking");
static_assert(sizeof(USteamProMatchmaking) == 0x0001D8, "Wrong size on USteamProMatchmaking");
static_assert(offsetof(USteamProMatchmaking, FavoritesListAccountsUpdated) == 0x000028, "Member 'USteamProMatchmaking::FavoritesListAccountsUpdated' has a wrong offset!");
static_assert(offsetof(USteamProMatchmaking, FavoritesListChanged) == 0x000038, "Member 'USteamProMatchmaking::FavoritesListChanged' has a wrong offset!");
static_assert(offsetof(USteamProMatchmaking, LobbyChatMsg) == 0x000048, "Member 'USteamProMatchmaking::LobbyChatMsg' has a wrong offset!");
static_assert(offsetof(USteamProMatchmaking, LobbyChatUpdate) == 0x000058, "Member 'USteamProMatchmaking::LobbyChatUpdate' has a wrong offset!");
static_assert(offsetof(USteamProMatchmaking, LobbyDataUpdate) == 0x000068, "Member 'USteamProMatchmaking::LobbyDataUpdate' has a wrong offset!");
static_assert(offsetof(USteamProMatchmaking, LobbyEnter) == 0x000078, "Member 'USteamProMatchmaking::LobbyEnter' has a wrong offset!");
static_assert(offsetof(USteamProMatchmaking, LobbyGameCreated) == 0x000088, "Member 'USteamProMatchmaking::LobbyGameCreated' has a wrong offset!");
static_assert(offsetof(USteamProMatchmaking, LobbyInvite) == 0x000098, "Member 'USteamProMatchmaking::LobbyInvite' has a wrong offset!");
static_assert(offsetof(USteamProMatchmaking, LobbyKicked) == 0x0000A8, "Member 'USteamProMatchmaking::LobbyKicked' has a wrong offset!");

// Class SteamCorePro.SteamCoreProMatchmakingAsyncActionCreateLobby
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProMatchmakingAsyncActionCreateLobby final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProMatchmakingAsyncActionCreateLobby* CreateLobbyAsync(class UObject* WorldContextObject, ESteamLobbyType LobbyType, int32 MaxMembers, float Timeout);

	void HandleCallback(const struct FCreateLobbyData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProMatchmakingAsyncActionCreateLobby">();
	}
	static class USteamCoreProMatchmakingAsyncActionCreateLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProMatchmakingAsyncActionCreateLobby>();
	}
};
static_assert(alignof(USteamCoreProMatchmakingAsyncActionCreateLobby) == 0x000008, "Wrong alignment on USteamCoreProMatchmakingAsyncActionCreateLobby");
static_assert(sizeof(USteamCoreProMatchmakingAsyncActionCreateLobby) == 0x000040, "Wrong size on USteamCoreProMatchmakingAsyncActionCreateLobby");
static_assert(offsetof(USteamCoreProMatchmakingAsyncActionCreateLobby, OnCallback) == 0x000030, "Member 'USteamCoreProMatchmakingAsyncActionCreateLobby::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProMatchmakingAsyncActionRequestLobbyList
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProMatchmakingAsyncActionRequestLobbyList final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProMatchmakingAsyncActionRequestLobbyList* RequestLobbyListAsync(class UObject* WorldContextObject, float Timeout);

	void HandleCallback(const struct FLobbyMatchList& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProMatchmakingAsyncActionRequestLobbyList">();
	}
	static class USteamCoreProMatchmakingAsyncActionRequestLobbyList* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProMatchmakingAsyncActionRequestLobbyList>();
	}
};
static_assert(alignof(USteamCoreProMatchmakingAsyncActionRequestLobbyList) == 0x000008, "Wrong alignment on USteamCoreProMatchmakingAsyncActionRequestLobbyList");
static_assert(sizeof(USteamCoreProMatchmakingAsyncActionRequestLobbyList) == 0x000040, "Wrong size on USteamCoreProMatchmakingAsyncActionRequestLobbyList");
static_assert(offsetof(USteamCoreProMatchmakingAsyncActionRequestLobbyList, OnCallback) == 0x000030, "Member 'USteamCoreProMatchmakingAsyncActionRequestLobbyList::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProMatchmakingAsyncActionJoinLobby
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProMatchmakingAsyncActionJoinLobby final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProMatchmakingAsyncActionJoinLobby* JoinLobbyAsync(class UObject* WorldContextObject, const struct FSteamID& SteamIDLobby, float Timeout);

	void HandleCallback(const struct FJoinLobbyData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProMatchmakingAsyncActionJoinLobby">();
	}
	static class USteamCoreProMatchmakingAsyncActionJoinLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProMatchmakingAsyncActionJoinLobby>();
	}
};
static_assert(alignof(USteamCoreProMatchmakingAsyncActionJoinLobby) == 0x000008, "Wrong alignment on USteamCoreProMatchmakingAsyncActionJoinLobby");
static_assert(sizeof(USteamCoreProMatchmakingAsyncActionJoinLobby) == 0x000040, "Wrong size on USteamCoreProMatchmakingAsyncActionJoinLobby");
static_assert(offsetof(USteamCoreProMatchmakingAsyncActionJoinLobby, OnCallback) == 0x000030, "Member 'USteamCoreProMatchmakingAsyncActionJoinLobby::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProCreateSession
// 0x0120 (0x0150 - 0x0030)
class USteamCoreProCreateSession final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A2[0x100];                                   // 0x0050(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamCoreProCreateSession* CreateSteamCoreProSession(class UObject* WorldContextObject, const TMap<class FString, struct FSteamSessionSetting>& SessionSettings, const class FString& SessionName, int32 MaxPlayers, bool bUseLAN, bool bAllowInvites, bool bUsesPresence, bool bAllowJoinViaPresence, bool bAllowJoinViaPresenceFriendsOnly, bool bAntiCheatProtected, bool bUsesStats, bool bShouldAdvertise, bool bUseLobbiesVoiceChatIfAvailable, float Timeout);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProCreateSession">();
	}
	static class USteamCoreProCreateSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProCreateSession>();
	}
};
static_assert(alignof(USteamCoreProCreateSession) == 0x000008, "Wrong alignment on USteamCoreProCreateSession");
static_assert(sizeof(USteamCoreProCreateSession) == 0x000150, "Wrong size on USteamCoreProCreateSession");
static_assert(offsetof(USteamCoreProCreateSession, OnSuccess) == 0x000030, "Member 'USteamCoreProCreateSession::OnSuccess' has a wrong offset!");
static_assert(offsetof(USteamCoreProCreateSession, OnFailure) == 0x000040, "Member 'USteamCoreProCreateSession::OnFailure' has a wrong offset!");

// Class SteamCorePro.SteamCoreProFindSession
// 0x00A8 (0x00D8 - 0x0030)
class USteamCoreProFindSession final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A5[0x98];                                    // 0x0040(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamCoreProFindSession* FindSteamCoreProSessions(class UObject* WorldContextObject, const TMap<class FString, struct FSteamSessionSearchSetting>& SearchSettings, int32 MaxResults, bool bUseLAN, ESteamSessionFindType ServerType, ESteamLobbyDistanceFilter DistanceFilter, bool bEmptyServersOnly, bool bSecureServersOnly, float Timeout);

	void OnCompleted(bool bSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProFindSession">();
	}
	static class USteamCoreProFindSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProFindSession>();
	}
};
static_assert(alignof(USteamCoreProFindSession) == 0x000008, "Wrong alignment on USteamCoreProFindSession");
static_assert(sizeof(USteamCoreProFindSession) == 0x0000D8, "Wrong size on USteamCoreProFindSession");
static_assert(offsetof(USteamCoreProFindSession, OnCallback) == 0x000030, "Member 'USteamCoreProFindSession::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProDestroySession
// 0x0040 (0x0070 - 0x0030)
class USteamCoreProDestroySession final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A7[0x20];                                    // 0x0050(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamCoreProDestroySession* DestroySteamCoreProSession(class UObject* WorldContextObject, float Timeout);

	void OnCompleted(class FName SessionName, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProDestroySession">();
	}
	static class USteamCoreProDestroySession* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProDestroySession>();
	}
};
static_assert(alignof(USteamCoreProDestroySession) == 0x000008, "Wrong alignment on USteamCoreProDestroySession");
static_assert(sizeof(USteamCoreProDestroySession) == 0x000070, "Wrong size on USteamCoreProDestroySession");
static_assert(offsetof(USteamCoreProDestroySession, OnSuccess) == 0x000030, "Member 'USteamCoreProDestroySession::OnSuccess' has a wrong offset!");
static_assert(offsetof(USteamCoreProDestroySession, OnFailure) == 0x000040, "Member 'USteamCoreProDestroySession::OnFailure' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUpdateSession
// 0x0030 (0x0060 - 0x0030)
class USteamCoreProUpdateSession final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_22AA[0x20];                                    // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamCoreProUpdateSession* UpdateSteamCoreProSession(class UObject* WorldContextObject, const TMap<class FString, struct FSteamSessionSearchSetting>& Settings, const class FString& SessionName, int32 MaxPlayers);

	void OnCompleted(class FName SessionName, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUpdateSession">();
	}
	static class USteamCoreProUpdateSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUpdateSession>();
	}
};
static_assert(alignof(USteamCoreProUpdateSession) == 0x000008, "Wrong alignment on USteamCoreProUpdateSession");
static_assert(sizeof(USteamCoreProUpdateSession) == 0x000060, "Wrong size on USteamCoreProUpdateSession");
static_assert(offsetof(USteamCoreProUpdateSession, OnCallback) == 0x000030, "Member 'USteamCoreProUpdateSession::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamProMatchmakingServers
// 0x0000 (0x0028 - 0x0028)
class USteamProMatchmakingServers final : public USteamCoreInterface
{
public:
	static class USteamProMatchmakingServers* GetSteamMatchmakingServers();

	void PingServer(const TDelegate<void(struct FGameServerItem& Data, bool bWasSuccessful)>& Callback, const class FString& IP, int32 QueryPort);
	void RequestFavoritesServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	void RequestFriendsServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	void RequestHistoryServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	void RequestInternetServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	void RequestLANServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	void RequestSpectatorServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	void ServerRules(const TDelegate<void(TArray<struct FGameServerRule>& Data, bool bWasSuccessful)>& Callback, const class FString& IP, int32 QueryPort);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProMatchmakingServers">();
	}
	static class USteamProMatchmakingServers* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProMatchmakingServers>();
	}
};
static_assert(alignof(USteamProMatchmakingServers) == 0x000008, "Wrong alignment on USteamProMatchmakingServers");
static_assert(sizeof(USteamProMatchmakingServers) == 0x000028, "Wrong size on USteamProMatchmakingServers");

// Class SteamCorePro.SteamCoreProMatchmakingServersAsyncActionPingServer
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProMatchmakingServersAsyncActionPingServer final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static void CancelPingQueries(class UObject* WorldContextObject);
	static class USteamCoreProMatchmakingServersAsyncActionPingServer* PingServerAsync(class UObject* WorldContextObject, const class FString& IP, int32 Port, float Timeout);

	void HandleCallback(const struct FGameServerItem& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProMatchmakingServersAsyncActionPingServer">();
	}
	static class USteamCoreProMatchmakingServersAsyncActionPingServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProMatchmakingServersAsyncActionPingServer>();
	}
};
static_assert(alignof(USteamCoreProMatchmakingServersAsyncActionPingServer) == 0x000008, "Wrong alignment on USteamCoreProMatchmakingServersAsyncActionPingServer");
static_assert(sizeof(USteamCoreProMatchmakingServersAsyncActionPingServer) == 0x000040, "Wrong size on USteamCoreProMatchmakingServersAsyncActionPingServer");
static_assert(offsetof(USteamCoreProMatchmakingServersAsyncActionPingServer, OnCallback) == 0x000030, "Member 'USteamCoreProMatchmakingServersAsyncActionPingServer::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProMatchmakingServersAsyncActionRequestServerList
// 0x0020 (0x0050 - 0x0030)
class USteamCoreProMatchmakingServersAsyncActionRequestServerList final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRefreshCompleted;                                // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static void CancelServerListQueries(class UObject* WorldContextObject);
	static class USteamCoreProMatchmakingServersAsyncActionRequestServerList* RequestFavoritesServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	static class USteamCoreProMatchmakingServersAsyncActionRequestServerList* RequestFriendsServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	static class USteamCoreProMatchmakingServersAsyncActionRequestServerList* RequestHistoryServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	static class USteamCoreProMatchmakingServersAsyncActionRequestServerList* RequestInternetServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	static class USteamCoreProMatchmakingServersAsyncActionRequestServerList* RequestLANServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	static class USteamCoreProMatchmakingServersAsyncActionRequestServerList* RequestSpectatorServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);

	void HandleCallback(const struct FGameServerItem& Data);
	void HandleServerListFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProMatchmakingServersAsyncActionRequestServerList">();
	}
	static class USteamCoreProMatchmakingServersAsyncActionRequestServerList* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProMatchmakingServersAsyncActionRequestServerList>();
	}
};
static_assert(alignof(USteamCoreProMatchmakingServersAsyncActionRequestServerList) == 0x000008, "Wrong alignment on USteamCoreProMatchmakingServersAsyncActionRequestServerList");
static_assert(sizeof(USteamCoreProMatchmakingServersAsyncActionRequestServerList) == 0x000050, "Wrong size on USteamCoreProMatchmakingServersAsyncActionRequestServerList");
static_assert(offsetof(USteamCoreProMatchmakingServersAsyncActionRequestServerList, OnCallback) == 0x000030, "Member 'USteamCoreProMatchmakingServersAsyncActionRequestServerList::OnCallback' has a wrong offset!");
static_assert(offsetof(USteamCoreProMatchmakingServersAsyncActionRequestServerList, OnRefreshCompleted) == 0x000040, "Member 'USteamCoreProMatchmakingServersAsyncActionRequestServerList::OnRefreshCompleted' has a wrong offset!");

// Class SteamCorePro.SteamCoreProMatchmakingServersAsyncActionServerRules
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProMatchmakingServersAsyncActionServerRules final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static void CancelServerRulesQueries(class UObject* WorldContextObject);
	static class USteamCoreProMatchmakingServersAsyncActionServerRules* ServerRulesAsync(class UObject* WorldContextObject, const class FString& IP, int32 QueryPort, float Timeout);

	void HandleCallback(const TArray<struct FGameServerRule>& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProMatchmakingServersAsyncActionServerRules">();
	}
	static class USteamCoreProMatchmakingServersAsyncActionServerRules* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProMatchmakingServersAsyncActionServerRules>();
	}
};
static_assert(alignof(USteamCoreProMatchmakingServersAsyncActionServerRules) == 0x000008, "Wrong alignment on USteamCoreProMatchmakingServersAsyncActionServerRules");
static_assert(sizeof(USteamCoreProMatchmakingServersAsyncActionServerRules) == 0x000040, "Wrong size on USteamCoreProMatchmakingServersAsyncActionServerRules");
static_assert(offsetof(USteamCoreProMatchmakingServersAsyncActionServerRules, OnCallback) == 0x000030, "Member 'USteamCoreProMatchmakingServersAsyncActionServerRules::OnCallback' has a wrong offset!");

// Class SteamCorePro.ServerFilter
// 0x0010 (0x0038 - 0x0028)
class UServerFilter final : public UObject
{
public:
	uint8                                         Pad_22BD[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddFilterAnd(const class FString& Value);
	void AddFilterDedicated();
	void AddFilterGameAddr(const class FString& Value);
	void AddFilterGameDataAnd(const class FString& Value);
	void AddFilterGameDataNor(const class FString& Value);
	void AddFilterGameDataOr(const class FString& Value);
	void AddFilterGameTagsAnd(const class FString& Value);
	void AddFilterGameTagsNor(const class FString& Value);
	void AddFilterHasPlayers();
	void AddFilterLinux();
	void AddFilterMap(const class FString& Value);
	void AddFilterName(const class FString& Value);
	void AddFilterNand(const class FString& Value);
	void AddFilterNoPlayers();
	void AddFilterNor(const class FString& Value);
	void AddFilterNotAppId(const class FString& Value);
	void AddFilterNotFull();
	void AddFilterOr(const class FString& Value);
	void AddFilterPassword();
	void AddFilterProxy();
	void AddFilterSecure();
	void AddFilterVersion(const class FString& Value);
	void AddFilterWhitelisted();
	TMap<class FString, class FString> GetFilters();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerFilter">();
	}
	static class UServerFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerFilter>();
	}
};
static_assert(alignof(UServerFilter) == 0x000008, "Wrong alignment on UServerFilter");
static_assert(sizeof(UServerFilter) == 0x000038, "Wrong size on UServerFilter");

// Class SteamCorePro.SteamProMusic
// 0x0060 (0x0088 - 0x0028)
class USteamProMusic final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             PlaybackStatusHasChanged;                          // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             VolumeHasChanged;                                  // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BE[0x40];                                    // 0x0048(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamProMusic* GetSteamMusic();

	bool bIsEnabled();
	bool BIsPlaying();
	ESteamAudioPlaybackStatus GetPlaybackStatus();
	float GetVolume();
	void Pause();
	void Play();
	void PlayNext();
	void PlayPrevious();
	void SetVolume(float FlVolume);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProMusic">();
	}
	static class USteamProMusic* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProMusic>();
	}
};
static_assert(alignof(USteamProMusic) == 0x000008, "Wrong alignment on USteamProMusic");
static_assert(sizeof(USteamProMusic) == 0x000088, "Wrong size on USteamProMusic");
static_assert(offsetof(USteamProMusic, PlaybackStatusHasChanged) == 0x000028, "Member 'USteamProMusic::PlaybackStatusHasChanged' has a wrong offset!");
static_assert(offsetof(USteamProMusic, VolumeHasChanged) == 0x000038, "Member 'USteamProMusic::VolumeHasChanged' has a wrong offset!");

// Class SteamCorePro.SteamProNetworking
// 0x0060 (0x0088 - 0x0028)
class USteamProNetworking final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             OnP2PSessionRequestDelegate;                       // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnP2PSessionConnectFailDelegate;                   // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BF[0x40];                                    // 0x0048(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamProNetworking* GetSteamNetworking();

	bool AcceptP2PSessionWithUser(const struct FSteamID& SteamIDRemote);
	bool AllowP2PPacketRelay(bool bAllow);
	bool CloseP2PChannelWithUser(const struct FSteamID& SteamIDRemote, int32 Channel);
	bool CloseP2PSessionWithUser(const struct FSteamID& SteamIDRemote);
	bool GetP2PSessionState(const struct FSteamID& SteamIDRemote, struct FSteamP2PSessionState* ConnectionState);
	bool IsP2PPacketAvailable(int32* MessageSize, int32 Channel);
	bool ReadP2PPacket(TArray<uint8>* Data, struct FSteamID* OutSteamIdRemote, int32 MessageSize, int32 Channel);
	bool SendP2PPacket(const struct FSteamID& SteamIDRemote, const TArray<uint8>& Data, ESteamP2PSend P2PSendType, int32 Channel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProNetworking">();
	}
	static class USteamProNetworking* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProNetworking>();
	}
};
static_assert(alignof(USteamProNetworking) == 0x000008, "Wrong alignment on USteamProNetworking");
static_assert(sizeof(USteamProNetworking) == 0x000088, "Wrong size on USteamProNetworking");
static_assert(offsetof(USteamProNetworking, OnP2PSessionRequestDelegate) == 0x000028, "Member 'USteamProNetworking::OnP2PSessionRequestDelegate' has a wrong offset!");
static_assert(offsetof(USteamProNetworking, OnP2PSessionConnectFailDelegate) == 0x000038, "Member 'USteamProNetworking::OnP2PSessionConnectFailDelegate' has a wrong offset!");

// Class SteamCorePro.SteamProNetworkingUtils
// 0x0000 (0x0028 - 0x0028)
class USteamProNetworkingUtils final : public USteamCoreInterface
{
public:
	static void ConvertPingLocationToString(const struct FSteamNetworkPingLocation& Location, class FString* String);
	static class USteamProNetworkingUtils* GetSteamNetworkingUtils();
	static bool ParsePingLocationString(const class FString& String, struct FSteamNetworkPingLocation* Result);

	bool CheckPingDataUpToDate(float MaxAgeSeconds);
	int32 EstimatePingTimeBetweenTwoLocations(const struct FSteamNetworkPingLocation& Location1, const struct FSteamNetworkPingLocation& Location2);
	int32 EstimatePingTimeFromLocalHost(const struct FSteamNetworkPingLocation& RemoteLocation);
	float GetLocalPingLocation(struct FSteamNetworkPingLocation* Result);
	void InitRelayNetworkAccess();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProNetworkingUtils">();
	}
	static class USteamProNetworkingUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProNetworkingUtils>();
	}
};
static_assert(alignof(USteamProNetworkingUtils) == 0x000008, "Wrong alignment on USteamProNetworkingUtils");
static_assert(sizeof(USteamProNetworkingUtils) == 0x000028, "Wrong size on USteamProNetworkingUtils");

// Class SteamCorePro.SteamProParentalSettings
// 0x0000 (0x0028 - 0x0028)
class USteamProParentalSettings final : public USteamCoreInterface
{
public:
	static class USteamProParentalSettings* GetSteamParentalSettings();

	bool BIsAppBlocked(int32 AppID);
	bool BIsAppInBlockList(int32 AppID);
	bool BIsFeatureBlocked(ESteamParentalFeature Feature);
	bool BIsFeatureInBlockList(ESteamParentalFeature Feature);
	bool BIsParentalLockEnabled();
	bool BIsParentalLockLocked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProParentalSettings">();
	}
	static class USteamProParentalSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProParentalSettings>();
	}
};
static_assert(alignof(USteamProParentalSettings) == 0x000008, "Wrong alignment on USteamProParentalSettings");
static_assert(sizeof(USteamProParentalSettings) == 0x000028, "Wrong size on USteamProParentalSettings");

// Class SteamCorePro.SteamCoreProSteamPartiesAsyncActionJoinParty
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProSteamPartiesAsyncActionJoinParty final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProSteamPartiesAsyncActionJoinParty* JoinPartyAsync(class UObject* WorldContextObject, const struct FPartyBeaconID& BeaconID, float Timeout);

	void HandleCallback(const struct FJoinPartyData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProSteamPartiesAsyncActionJoinParty">();
	}
	static class USteamCoreProSteamPartiesAsyncActionJoinParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProSteamPartiesAsyncActionJoinParty>();
	}
};
static_assert(alignof(USteamCoreProSteamPartiesAsyncActionJoinParty) == 0x000008, "Wrong alignment on USteamCoreProSteamPartiesAsyncActionJoinParty");
static_assert(sizeof(USteamCoreProSteamPartiesAsyncActionJoinParty) == 0x000040, "Wrong size on USteamCoreProSteamPartiesAsyncActionJoinParty");
static_assert(offsetof(USteamCoreProSteamPartiesAsyncActionJoinParty, OnCallback) == 0x000030, "Member 'USteamCoreProSteamPartiesAsyncActionJoinParty::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProSteamPartiesAsyncActionCreateBeacon
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProSteamPartiesAsyncActionCreateBeacon final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProSteamPartiesAsyncActionCreateBeacon* CreateBeaconAsync(class UObject* WorldContextObject, int32 OpenSlots, const struct FSteamPartyBeaconLocation& BeaconLocation, const class FString& ConnectString, const class FString& MetaData, float Timeout);

	void HandleCallback(const struct FCreateBeaconData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProSteamPartiesAsyncActionCreateBeacon">();
	}
	static class USteamCoreProSteamPartiesAsyncActionCreateBeacon* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProSteamPartiesAsyncActionCreateBeacon>();
	}
};
static_assert(alignof(USteamCoreProSteamPartiesAsyncActionCreateBeacon) == 0x000008, "Wrong alignment on USteamCoreProSteamPartiesAsyncActionCreateBeacon");
static_assert(sizeof(USteamCoreProSteamPartiesAsyncActionCreateBeacon) == 0x000040, "Wrong size on USteamCoreProSteamPartiesAsyncActionCreateBeacon");
static_assert(offsetof(USteamCoreProSteamPartiesAsyncActionCreateBeacon, OnCallback) == 0x000030, "Member 'USteamCoreProSteamPartiesAsyncActionCreateBeacon::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots* ChangeNumOpenSlotsAsync(class UObject* WorldContextObject, const struct FPartyBeaconID& BeaconID, int32 OpenSlots, float Timeout);

	void HandleCallback(const struct FChangeNumOpenSlotsData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots">();
	}
	static class USteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots>();
	}
};
static_assert(alignof(USteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots) == 0x000008, "Wrong alignment on USteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots");
static_assert(sizeof(USteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots) == 0x000040, "Wrong size on USteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots");
static_assert(offsetof(USteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots, OnCallback) == 0x000030, "Member 'USteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamProApps
// 0x0060 (0x0088 - 0x0028)
class USteamProApps final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             DLCInstalled;                                      // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FileDetailsResultDelegate;                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D4[0x40];                                    // 0x0048(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool BGetDLCDataByIndex(int32 DLC, int32* AppID, bool* bAvailable, class FString* Param_Name);
	static bool BIsAppInstalled(int32 AppID);
	static bool BIsCybercafe();
	static bool BIsDlcInstalled(int32 AppID);
	static bool BIsLowViolence();
	static bool BIsSubscribed();
	static bool BIsSubscribedApp(int32 AppID);
	static bool BIsSubscribedFromFamilySharing();
	static bool BIsSubscribedFromFreeWeekend();
	static bool BIsTimedTrial(int32* SecondsAllowed, int32* SecondsPlayed);
	static bool BIsVACBanned();
	static int32 GetAppBuildId();
	static int32 GetAppInstallDir(int32 AppID, class FString* Folder);
	static struct FSteamID GetAppOwner();
	static class FString GetAvailableGameLanguages();
	static bool GetCurrentBetaName(class FString* Param_Name);
	static class FString GetCurrentGameLanguage();
	static int32 GetDLCCount();
	static bool GetDlcDownloadProgress(int32 AppID, int32* BytesDownloaded, int32* BytesTotal);
	static int32 GetEarliestPurchaseUnixTime(int32 AppID);
	static int32 GetInstalledDepots(int32 AppID, int32 MaxDepots, TArray<int32>* Depots);
	static int32 GetLaunchCommandLine(class FString* CommandLine);
	static class FString GetLaunchQueryParam(const class FString& Key);
	static class USteamProApps* GetSteamApps();
	static void InstallDLC(int32 AppID);
	static bool MarkContentCorrupt(bool bMissingFilesOnly);
	static void UninstallDLC(int32 AppID);

	void GetFileDetails(const TDelegate<void(struct FFileDetailsResult& Data, bool bWasSuccessful)>& Callback, const class FString& Filename);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProApps">();
	}
	static class USteamProApps* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProApps>();
	}
};
static_assert(alignof(USteamProApps) == 0x000008, "Wrong alignment on USteamProApps");
static_assert(sizeof(USteamProApps) == 0x000088, "Wrong size on USteamProApps");
static_assert(offsetof(USteamProApps, DLCInstalled) == 0x000028, "Member 'USteamProApps::DLCInstalled' has a wrong offset!");
static_assert(offsetof(USteamProApps, FileDetailsResultDelegate) == 0x000038, "Member 'USteamProApps::FileDetailsResultDelegate' has a wrong offset!");

// Class SteamCorePro.SteamProGameSearch
// 0x0150 (0x0178 - 0x0028)
class USteamProGameSearch final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             SearchForGameProgressDelegate;                     // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SearchForGameResultDelegate;                       // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RequestPlayersForGameProgressDelegate;             // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RequestPlayersForGameResultDelegate;               // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RequestPlayersForGameFinalResultDelegate;          // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SubmitPlayerResultResultDelegate;                  // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EndGameResultDelegate;                             // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E1[0xE0];                                    // 0x0098(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamProGameSearch* GetSteamGameSearch();

	ESteamGameSearchErrorCode AcceptGame();
	ESteamGameSearchErrorCode AddGameSearchParams(const class FString& KeyToFind, const TArray<class FString>& ValuesToFind);
	ESteamGameSearchErrorCode CancelRequestPlayersForGame();
	ESteamGameSearchErrorCode DeclineGame();
	ESteamGameSearchErrorCode EndGame(const class FString& UniqueGameID);
	ESteamGameSearchErrorCode EndGameSearch();
	ESteamGameSearchErrorCode HostConfirmGameStart(const class FString& UniqueGameID);
	ESteamGameSearchErrorCode RequestPlayersForGame(int32 PlayerMin, int32 PlayerMax, int32 MaxTeamSize);
	ESteamGameSearchErrorCode RetrieveConnectionDetails(const struct FSteamID& SteamIDHost, class FString* ConnectionDetails, int32 NumConnectionDetails);
	ESteamGameSearchErrorCode SearchForGameSolo(int32 PlayerMin, int32 PlayerMax);
	ESteamGameSearchErrorCode SearchForGameWithLobby(const struct FSteamID& SteamIDLobby, int32 PlayerMin, int32 PlayerMax);
	ESteamGameSearchErrorCode SetConnectionDetails(const class FString& ConnectionDetails);
	ESteamGameSearchErrorCode SetGameHostParams(const class FString& Key, const TArray<class FString>& Values);
	ESteamGameSearchErrorCode SubmitPlayerResult(const class FString& UniqueGameID, const struct FSteamID& SteamIDPlayer, ESteamPlayerResult PlayerResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProGameSearch">();
	}
	static class USteamProGameSearch* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProGameSearch>();
	}
};
static_assert(alignof(USteamProGameSearch) == 0x000008, "Wrong alignment on USteamProGameSearch");
static_assert(sizeof(USteamProGameSearch) == 0x000178, "Wrong size on USteamProGameSearch");
static_assert(offsetof(USteamProGameSearch, SearchForGameProgressDelegate) == 0x000028, "Member 'USteamProGameSearch::SearchForGameProgressDelegate' has a wrong offset!");
static_assert(offsetof(USteamProGameSearch, SearchForGameResultDelegate) == 0x000038, "Member 'USteamProGameSearch::SearchForGameResultDelegate' has a wrong offset!");
static_assert(offsetof(USteamProGameSearch, RequestPlayersForGameProgressDelegate) == 0x000048, "Member 'USteamProGameSearch::RequestPlayersForGameProgressDelegate' has a wrong offset!");
static_assert(offsetof(USteamProGameSearch, RequestPlayersForGameResultDelegate) == 0x000058, "Member 'USteamProGameSearch::RequestPlayersForGameResultDelegate' has a wrong offset!");
static_assert(offsetof(USteamProGameSearch, RequestPlayersForGameFinalResultDelegate) == 0x000068, "Member 'USteamProGameSearch::RequestPlayersForGameFinalResultDelegate' has a wrong offset!");
static_assert(offsetof(USteamProGameSearch, SubmitPlayerResultResultDelegate) == 0x000078, "Member 'USteamProGameSearch::SubmitPlayerResultResultDelegate' has a wrong offset!");
static_assert(offsetof(USteamProGameSearch, EndGameResultDelegate) == 0x000088, "Member 'USteamProGameSearch::EndGameResultDelegate' has a wrong offset!");

// Class SteamCorePro.SteamProGameServer
// 0x00F0 (0x0118 - 0x0028)
class USteamProGameServer final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             GSPolicyResponse;                                  // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GSClientGroupStatus;                               // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GSValidateAuthTicketResponse;                      // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GSClientApprove;                                   // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GSClientDeny;                                      // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_22EC[0xA0];                                    // 0x0078(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamProGameServer* GetSteamGameServer();

	void AssociateWithClan(const TDelegate<void(struct FAssociateWithClanResult& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDClan);
	ESteamBeginAuthSessionResult BeginAuthSession(const TArray<uint8>& Ticket, const struct FSteamID& SteamID);
	bool BLoggedOn();
	bool BSecure();
	bool BUpdateUserData(const struct FSteamID& SteamIDUser, const class FString& PlayerName, int32 Score);
	void CancelAuthTicket(const struct FSteamTicketHandle& TicketHandle);
	void ClearAllKeyValues();
	void ComputeNewPlayerCompatibility(const TDelegate<void(struct FComputeNewPlayerCompatibilityResult& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDNewPlayer);
	struct FSteamID CreateUnauthenticatedUserConnection();
	void EndAuthSession(const struct FSteamID& SteamID);
	struct FSteamTicketHandle GetAuthSessionTicket(TArray<uint8>* Ticket, const struct FSteamNetworkingIdentity& SteamNetworkingIdentity);
	class FString GetServerPublicIP();
	class FString GetServerPublicIP_Pure();
	class FString GetServerPublicIP_PureCompact();
	struct FSteamID GetServerSteamID();
	struct FSteamID GetServerSteamID_Pure();
	struct FSteamID GetServerSteamID_PureCompact();
	void LogOff();
	void LogOn(const class FString& Token);
	void LogOnAnonymous();
	bool RequestUserGroupStatus(const struct FSteamID& SteamIDUser, const struct FSteamID& SteamIDGroup);
	void SetAdvertiseServerActive(bool bActive);
	void SetBotPlayerCount(int32 BotPlayers);
	void SetDedicatedServer(bool bDedicated);
	void SetGameData(const class FString& GameData);
	void SetGameDescription(const class FString& GameDescription);
	void SetGameTags(const class FString& GameTags);
	void SetKeyValue(const class FString& Key, const class FString& Value);
	void SetMapName(const class FString& MapName);
	void SetMaxPlayerCount(int32 PlayersMax);
	void SetModDir(const class FString& ModDir);
	void SetPasswordProtected(bool bPasswordProtected);
	void SetProduct(const class FString& Product);
	void SetRegion(const class FString& Region);
	void SetServerName(const class FString& ServerName);
	void SetSpectatorPort(int32 SpectatorPort);
	void SetSpectatorServerName(const class FString& SpectatorServerName);
	ESteamUserHasLicenseForAppResult UserHasLicenseForApp(const struct FSteamID& SteamID, int32 AppID);
	bool WasRestartRequested();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProGameServer">();
	}
	static class USteamProGameServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProGameServer>();
	}
};
static_assert(alignof(USteamProGameServer) == 0x000008, "Wrong alignment on USteamProGameServer");
static_assert(sizeof(USteamProGameServer) == 0x000118, "Wrong size on USteamProGameServer");
static_assert(offsetof(USteamProGameServer, GSPolicyResponse) == 0x000028, "Member 'USteamProGameServer::GSPolicyResponse' has a wrong offset!");
static_assert(offsetof(USteamProGameServer, GSClientGroupStatus) == 0x000038, "Member 'USteamProGameServer::GSClientGroupStatus' has a wrong offset!");
static_assert(offsetof(USteamProGameServer, GSValidateAuthTicketResponse) == 0x000048, "Member 'USteamProGameServer::GSValidateAuthTicketResponse' has a wrong offset!");
static_assert(offsetof(USteamProGameServer, GSClientApprove) == 0x000058, "Member 'USteamProGameServer::GSClientApprove' has a wrong offset!");
static_assert(offsetof(USteamProGameServer, GSClientDeny) == 0x000068, "Member 'USteamProGameServer::GSClientDeny' has a wrong offset!");

// Class SteamCorePro.SteamProParties
// 0x0120 (0x0148 - 0x0028)
class USteamProParties final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             JoinPartyDelegate;                                 // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             CreateBeaconDelegate;                              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ReservationNotificationDelegate;                   // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ChangeNumOpenSlotsDelegate;                        // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AvailableBeaconLocationsDelegate;                  // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ActiveBeaconsDelegate;                             // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F2[0xC0];                                    // 0x0088(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CancelReservation(const struct FPartyBeaconID& BeaconID, const struct FSteamID& SteamIDUser);
	static bool DestroyBeacon(const struct FPartyBeaconID& BeaconID);
	static bool GetAvailableBeaconLocations(TArray<struct FSteamPartyBeaconLocation>* LocationList, int32 MaxNumLocations);
	static struct FPartyBeaconID GetBeaconByIndex(int32 Param_Index);
	static bool GetBeaconDetails(const struct FPartyBeaconID& BeaconID, struct FSteamID* SteamIDBeaconOwner, struct FSteamPartyBeaconLocation* Location, class FString* OutMetadata);
	static bool GetBeaconLocationData(const struct FSteamPartyBeaconLocation& BeaconLocation, ESteamPartiesBeaconLocationData EData, class FString* PCHDataStringOut);
	static int32 GetNumActiveBeacons();
	static bool GetNumAvailableBeaconLocations(int32* NumLocations);
	static class USteamProParties* GetSteamParties();
	static void OnReservationCompleted(const struct FPartyBeaconID& BeaconID, const struct FSteamID& SteamIDUser);

	void ChangeNumOpenSlots(const TDelegate<void(struct FChangeNumOpenSlotsData& Data, bool bWasSuccessful)>& Callback, const struct FPartyBeaconID& BeaconID, int32 OpenSlots);
	void CreateBeacon(const TDelegate<void(struct FCreateBeaconData& Data, bool bWasSuccessful)>& Callback, int32 OpenSlots, const struct FSteamPartyBeaconLocation& BeaconLocation, const class FString& ConnectString, const class FString& MetaData);
	void JoinParty(const TDelegate<void(struct FJoinPartyData& Data, bool bWasSuccessful)>& Callback, const struct FPartyBeaconID& BeaconID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProParties">();
	}
	static class USteamProParties* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProParties>();
	}
};
static_assert(alignof(USteamProParties) == 0x000008, "Wrong alignment on USteamProParties");
static_assert(sizeof(USteamProParties) == 0x000148, "Wrong size on USteamProParties");
static_assert(offsetof(USteamProParties, JoinPartyDelegate) == 0x000028, "Member 'USteamProParties::JoinPartyDelegate' has a wrong offset!");
static_assert(offsetof(USteamProParties, CreateBeaconDelegate) == 0x000038, "Member 'USteamProParties::CreateBeaconDelegate' has a wrong offset!");
static_assert(offsetof(USteamProParties, ReservationNotificationDelegate) == 0x000048, "Member 'USteamProParties::ReservationNotificationDelegate' has a wrong offset!");
static_assert(offsetof(USteamProParties, ChangeNumOpenSlotsDelegate) == 0x000058, "Member 'USteamProParties::ChangeNumOpenSlotsDelegate' has a wrong offset!");
static_assert(offsetof(USteamProParties, AvailableBeaconLocationsDelegate) == 0x000068, "Member 'USteamProParties::AvailableBeaconLocationsDelegate' has a wrong offset!");
static_assert(offsetof(USteamProParties, ActiveBeaconsDelegate) == 0x000078, "Member 'USteamProParties::ActiveBeaconsDelegate' has a wrong offset!");

// Class SteamCorePro.SteamProRemotePlay
// 0x0060 (0x0088 - 0x0028)
class USteamProRemotePlay final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             SteamRemotePlaySessionConnected;                   // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamRemotePlaySessionDisconnected;                // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_22FC[0x40];                                    // 0x0048(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamProRemotePlay* GetSteamRemotePlay();

	bool BGetSessionClientResolution(int32 SessionID, int32* ResolutionX, int32* ResolutionY);
	bool BSendRemotePlayTogetherInvite(const struct FSteamID& SteamIDFriend);
	bool BStartRemotePlayTogether(bool bShowOverlay);
	ESteamCoreProDeviceFormFactor GetSessionClientFormFactor(int32 SessionID);
	class FString GetSessionClientName(int32 SessionID);
	int32 GetSessionCount();
	int32 GetSessionID(int32 SessionIndex);
	struct FSteamID GetSessionSteamID(int32 SessionID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProRemotePlay">();
	}
	static class USteamProRemotePlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProRemotePlay>();
	}
};
static_assert(alignof(USteamProRemotePlay) == 0x000008, "Wrong alignment on USteamProRemotePlay");
static_assert(sizeof(USteamProRemotePlay) == 0x000088, "Wrong size on USteamProRemotePlay");
static_assert(offsetof(USteamProRemotePlay, SteamRemotePlaySessionConnected) == 0x000028, "Member 'USteamProRemotePlay::SteamRemotePlaySessionConnected' has a wrong offset!");
static_assert(offsetof(USteamProRemotePlay, SteamRemotePlaySessionDisconnected) == 0x000038, "Member 'USteamProRemotePlay::SteamRemotePlaySessionDisconnected' has a wrong offset!");

// Class SteamCorePro.SteamProRemoteStorage
// 0x00C0 (0x00E8 - 0x0028)
class USteamProRemoteStorage final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             RemoteStorageUnsubscribePublishedFileResult;       // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RemoteStorageSubscribePublishedFileResult;         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RemoteStoragePublishedFileUnsubscribed;            // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RemoteStoragePublishedFileSubscribed;              // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2302[0x80];                                    // 0x0068(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool BeginFileWriteBatch();
	static bool EndFileWriteBatch();
	static bool FileDelete(const class FString& File);
	static bool FileExists(const class FString& File);
	static bool FileForget(const class FString& File);
	static bool FilePersisted(const class FString& File);
	static int32 FileRead(const class FString& File, TArray<uint8>* Buffer, int32 DataToRead);
	static bool FileReadAsyncComplete(const struct FRemoteStorageFileReadAsyncComplete& ReadCall, TArray<uint8>* Buffer, int32 BytesToRead);
	static bool FileWrite(const class FString& File, const TArray<uint8>& Data);
	static bool FileWriteStreamCancel(const struct FUGCFileWriteStreamHandle& Handle);
	static bool FileWriteStreamClose(const struct FUGCFileWriteStreamHandle& Handle);
	static struct FUGCFileWriteStreamHandle FileWriteStreamOpen(const class FString& File);
	static bool FileWriteStreamWriteChunk(const struct FUGCFileWriteStreamHandle& Handle, const TArray<uint8>& Data);
	static int32 GetCachedUGCCount();
	static struct FSteamUGCHandle GetCachedUGCHandle(int32 ICachedContent);
	static int32 GetFileCount();
	static class FString GetFileNameAndSize(int32 File, int32* FileSizeInBytes);
	static int32 GetFileSize(const class FString& File);
	static int32 GetFileTimestamp(const class FString& File);
	static int32 GetLocalFileChangeCount();
	static bool GetQuota(int32* TotalBytes, int32* AvailableBytes);
	static class USteamProRemoteStorage* GetSteamRemoteStorage();
	static ESteamRemoteStoragePlatform GetSyncPlatforms(const class FString& File);
	static bool GetUGCDetails(const struct FSteamUGCHandle& Handle, int32* AppID, class FString* Param_Name, int32* FileSizeInBytes, struct FSteamID* SteamIDOwner);
	static bool GetUGCDownloadProgress(const struct FSteamUGCHandle& Handle, int32* BytesDownloaded, int32* BytesExpected);
	static bool IsCloudEnabledForAccount();
	static bool IsCloudEnabledForApp();
	static void SetCloudEnabledForApp(bool bEnabled);
	static bool SetSyncPlatforms(const class FString& File, ESteamRemoteStoragePlatform RemoteStoragePlatform);
	static int32 UGCRead(const struct FSteamUGCHandle& Content, TArray<uint8>* OutData, int32 DataToRead, int32 Offset, ESteamUGCReadAction Action);

	void FileReadAsync(const TDelegate<void(struct FRemoteStorageFileReadAsyncComplete& Data, bool bWasSuccessful)>& Callback, const class FString& File, int32 Offset, int32 BytesToRead);
	void FileShare(const TDelegate<void(struct FRemoteStorageFileShareResult& Data, bool bWasSuccessful)>& Callback, const class FString& File);
	void FileWriteAsync(const TDelegate<void(struct FRemoteStorageFileWriteAsyncComplete& Data, bool bWasSuccessful)>& Callback, const class FString& File, const TArray<uint8>& Data);
	void UGCDownload(const TDelegate<void(struct FRemoteStorageDownloadUGCResult& Data, bool bWasSuccessful)>& Callback, const struct FSteamUGCHandle& Content, int32 Priority);
	void UGCDownloadToLocation(const TDelegate<void(struct FRemoteStorageDownloadUGCResult& Data, bool bWasSuccessful)>& Callback, const struct FSteamUGCHandle& Content, const class FString& Location, int32 Priority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProRemoteStorage">();
	}
	static class USteamProRemoteStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProRemoteStorage>();
	}
};
static_assert(alignof(USteamProRemoteStorage) == 0x000008, "Wrong alignment on USteamProRemoteStorage");
static_assert(sizeof(USteamProRemoteStorage) == 0x0000E8, "Wrong size on USteamProRemoteStorage");
static_assert(offsetof(USteamProRemoteStorage, RemoteStorageUnsubscribePublishedFileResult) == 0x000028, "Member 'USteamProRemoteStorage::RemoteStorageUnsubscribePublishedFileResult' has a wrong offset!");
static_assert(offsetof(USteamProRemoteStorage, RemoteStorageSubscribePublishedFileResult) == 0x000038, "Member 'USteamProRemoteStorage::RemoteStorageSubscribePublishedFileResult' has a wrong offset!");
static_assert(offsetof(USteamProRemoteStorage, RemoteStoragePublishedFileUnsubscribed) == 0x000048, "Member 'USteamProRemoteStorage::RemoteStoragePublishedFileUnsubscribed' has a wrong offset!");
static_assert(offsetof(USteamProRemoteStorage, RemoteStoragePublishedFileSubscribed) == 0x000058, "Member 'USteamProRemoteStorage::RemoteStoragePublishedFileSubscribed' has a wrong offset!");

// Class SteamCorePro.SteamProScreenshots
// 0x0060 (0x0088 - 0x0028)
class USteamProScreenshots final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             ScreenshotReady;                                   // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ScreenshotRequested;                               // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2319[0x40];                                    // 0x0048(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FScreenshotHandle AddScreenshotToLibrary(const class FString& Filename, const class FString& ThumbnailFilename, int32 Width, int32 Height);
	static struct FScreenshotHandle AddVRScreenshotToLibrary(ESteamVRScreenshotType EType, const class FString& Filename, const class FString& VRFileName);
	static class USteamProScreenshots* GetSteamScreenshots();
	static void HookScreenshots(bool bHook);
	static bool IsScreenshotsHooked();
	static bool SetLocation(const struct FScreenshotHandle& Handle, const class FString& Location);
	static bool TagPublishedFile(const struct FScreenshotHandle& Handle, const struct FPublishedFileID& PublishedFileID);
	static bool TagUser(const struct FScreenshotHandle& Handle, const struct FSteamID& SteamID);
	static void TriggerScreenshot();
	static struct FScreenshotHandle WriteScreenshot(const TArray<uint8>& PubRGB, int32 Width, int32 Height);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProScreenshots">();
	}
	static class USteamProScreenshots* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProScreenshots>();
	}
};
static_assert(alignof(USteamProScreenshots) == 0x000008, "Wrong alignment on USteamProScreenshots");
static_assert(sizeof(USteamProScreenshots) == 0x000088, "Wrong size on USteamProScreenshots");
static_assert(offsetof(USteamProScreenshots, ScreenshotReady) == 0x000028, "Member 'USteamProScreenshots::ScreenshotReady' has a wrong offset!");
static_assert(offsetof(USteamProScreenshots, ScreenshotRequested) == 0x000038, "Member 'USteamProScreenshots::ScreenshotRequested' has a wrong offset!");

// Class SteamCorePro.SteamProUGC
// 0x00C0 (0x00E8 - 0x0028)
class USteamProUGC final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             ItemInstalled;                                     // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DownloadItemResult;                                // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserSubscribedItemsListChanged;                    // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             WorkshopEULAStatus;                                // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2324[0x80];                                    // 0x0068(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool AddContentDescriptor(const struct FUGCUpdateHandle& Handle, ESteamUGCContentDescriptorID DescId);
	static bool AddExcludedTag(const struct FUGCQueryHandle& Handle, const class FString& TagName);
	static bool AddItemKeyValueTag(const struct FUGCUpdateHandle& Handle, const class FString& Key, const class FString& Value);
	static bool AddItemPreviewFile(const struct FUGCUpdateHandle& Handle, const class FString& PreviewFile, ESteamItemPreviewType Type);
	static bool AddItemPreviewVideo(const struct FUGCUpdateHandle& Handle, const class FString& VideoID);
	static bool AddRequiredKeyValueTag(const struct FUGCQueryHandle& Handle, const class FString& Key, const class FString& Value);
	static bool AddRequiredTag(const struct FUGCQueryHandle& Handle, const class FString& TagName);
	static bool AddRequiredTagGroup(const struct FUGCQueryHandle& Handle, const TArray<class FString>& TagGroups);
	static bool BInitWorkshopForGameServer(int32 WorkshopDepotID, const class FString& Folder);
	static struct FUGCQueryHandle CreateQueryAllUGCRequest(ESteamUGCQuery QueryType, ESteamUGCMatchingUGCType FileType, int32 CreatorAppID, int32 ConsumerAppID, int32 Page);
	static struct FUGCQueryHandle CreateQueryUGCDetailsRequest(const TArray<struct FPublishedFileID>& PublishedFileIDs);
	static struct FUGCQueryHandle CreateQueryUserUGCRequest(const struct FSteamID& SteamID, ESteamUserUGCList ListType, ESteamUGCMatchingUGCType MatchingUGCType, ESteamUserUGCListSortOrder SortOrder, int32 CreatorAppID, int32 ConsumerAppID, int32 Page);
	static bool DownloadItem(const struct FPublishedFileID& PublishedFileID, bool bHighPriority);
	static bool GetItemDownloadInfo(const struct FPublishedFileID& PublishedFileID, int32* BytesDownloaded, int32* BytesTotal);
	static bool GetItemInstallInfo(const struct FPublishedFileID& PublishedFileID, int32* SizeOnDisk, class FString* Folder, int32* Timestamp);
	static int32 GetItemState(const struct FPublishedFileID& PublishedFileID, TArray<ESteamItemState>* States);
	static ESteamItemUpdateStatus GetItemUpdateProgress(const struct FUGCUpdateHandle& Handle, int32* BytesProcessed, int32* BytesTotal);
	static int32 GetNumSubscribedItems();
	static bool GetQueryUGCAdditionalPreview(const struct FUGCQueryHandle& Handle, int32 Param_Index, int32 PreviewIndex, class FString* URLOrVideoID, class FString* OriginalFileName, ESteamItemPreviewType* PreviewType);
	static bool GetQueryUGCChildren(const struct FUGCQueryHandle& Handle, int32 Param_Index, TArray<struct FPublishedFileID>* PublishedFileIDs, int32 MaxEntries);
	static bool GetQueryUGCKeyValueTag(const struct FUGCQueryHandle& Handle, int32 Param_Index, int32 KeyValueTagIndex, class FString* Key, class FString* Value);
	static bool GetQueryUGCMetadata(const struct FUGCQueryHandle& Handle, int32 Param_Index, class FString* MetaData, int32 MetadataSize);
	static int32 GetQueryUGCNumAdditionalPreviews(const struct FUGCQueryHandle& Handle, int32 Param_Index);
	static int32 GetQueryUGCNumKeyValueTags(const struct FUGCQueryHandle& Handle, int32 Param_Index);
	static int32 GetQueryUGCNumTags(const struct FUGCQueryHandle& Handle, int32 Param_Index);
	static bool GetQueryUGCPreviewURL(const struct FUGCQueryHandle& Handle, int32 Param_Index, class FString* URL);
	static bool GetQueryUGCResult(const struct FUGCQueryHandle& Handle, int32 Param_Index, struct FSteamUGCDetails* Details);
	static bool GetQueryUGCStatistic(const struct FUGCQueryHandle& Handle, int32 Param_Index, ESteamItemStatistic StatType, class FString* StatValue);
	static bool GetQueryUGCTag(const struct FUGCQueryHandle& Handle, int32 Param_Index, int32 IndexTag, class FString* Value);
	static bool GetQueryUGCTagDisplayName(const struct FUGCQueryHandle& Handle, int32 Param_Index, int32 IndexTag, class FString* Value);
	static class USteamProUGC* GetSteamUGC();
	static int32 GetSubscribedItems(TArray<struct FPublishedFileID>* PublishedFileIDs, int32 MaxEntries);
	static int32 GetUserContentDescriptorPreferences(const TArray<ESteamUGCContentDescriptorID>& Descriptors, int32 MaxEntries);
	static bool ReleaseQueryUGCRequest(const struct FUGCQueryHandle& Handle);
	static bool RemoveContentDescriptor(const struct FUGCUpdateHandle& Handle, ESteamUGCContentDescriptorID DescId);
	static bool RemoveItemKeyValueTags(const struct FUGCUpdateHandle& Handle, const class FString& Key);
	static bool RemoveItemPreview(const struct FUGCUpdateHandle& Handle, int32 Param_Index);
	static bool SetAllowCachedResponse(const struct FUGCQueryHandle& Handle, int32 MaxAgeSeconds);
	static bool SetCloudFileNameFilter(const struct FUGCQueryHandle& Handle, const class FString& MatchCloudFileName);
	static bool SetItemContent(const struct FUGCUpdateHandle& Handle, const class FString& ContentFolder);
	static bool SetItemDescription(const struct FUGCUpdateHandle& Handle, const class FString& Description);
	static bool SetItemMetadata(const struct FUGCUpdateHandle& Handle, const class FString& MetaData);
	static bool SetItemPreview(const struct FUGCUpdateHandle& Handle, const class FString& PreviewFile);
	static bool SetItemTags(const struct FUGCUpdateHandle& Handle, const TArray<class FString>& Tags);
	static bool SetItemTitle(const struct FUGCUpdateHandle& Handle, const class FString& Title);
	static bool SetItemUpdateLanguage(const struct FUGCUpdateHandle& Handle, const class FString& Language);
	static bool SetItemVisibility(const struct FUGCUpdateHandle& Handle, ESteamRemoteStoragePublishedFileVisibility Visibility);
	static bool SetLanguage(const struct FUGCQueryHandle& Handle, const class FString& Language);
	static bool SetMatchAnyTag(const struct FUGCQueryHandle& Handle, bool bMatchAnyTag);
	static bool SetRankedByTrendDays(const struct FUGCQueryHandle& Handle, int32 Days);
	static bool SetReturnAdditionalPreviews(const struct FUGCQueryHandle& Handle, bool bReturnAdditionalPreviews);
	static bool SetReturnChildren(const struct FUGCQueryHandle& Handle, bool bReturnChildren);
	static bool SetReturnKeyValueTags(const struct FUGCQueryHandle& Handle, bool bReturnKeyValueTags);
	static bool SetReturnLongDescription(const struct FUGCQueryHandle& Handle, bool bReturnLongDescription);
	static bool SetReturnMetadata(const struct FUGCQueryHandle& Handle, bool bReturnMetadata);
	static bool SetReturnOnlyIDs(const struct FUGCQueryHandle& Handle, bool bReturnOnlyIDs);
	static bool SetReturnPlaytimeStats(const struct FUGCQueryHandle& Handle, int32 Days);
	static bool SetReturnTotalOnly(const struct FUGCQueryHandle& Handle, bool bReturnTotalOnly);
	static bool SetSearchText(const struct FUGCQueryHandle& Handle, const class FString& SearchText);
	static bool ShowWorkshopEULA();
	static struct FUGCUpdateHandle StartItemUpdate(int32 ConsumerAppID, const struct FPublishedFileID& PublishedFileID);
	static void SuspendDownloads(bool bSuspend);
	static bool UpdateItemPreviewFile(const struct FUGCUpdateHandle& Handle, int32 Param_Index, const class FString& PreviewFile);
	static bool UpdateItemPreviewVideo(const struct FUGCUpdateHandle& Handle, int32 Param_Index, const class FString& PreviewVideo);

	void AddAppDependency(const TDelegate<void(struct FAddAppDependencyResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID, int32 AppID);
	void AddDependency(const TDelegate<void(struct FAddUGCDependencyResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID, const struct FPublishedFileID& ChildPublishedFileId);
	void AddItemToFavorites(const TDelegate<void(struct FUserFavoriteItemsListChanged& Data, bool bWasSuccessful)>& Callback, int32 AppID, const struct FPublishedFileID& PublishedFileID);
	void CreateItem(const TDelegate<void(struct FCreateItemResult& Data, bool bWasSuccessful)>& Callback, int32 ConsumerAppID, ESteamWorkshopFileType FileType);
	void DeleteItem(const TDelegate<void(struct FUGCDeleteItemResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID);
	void GetAppDependencies(const TDelegate<void(struct FGetAppDependenciesResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID);
	void GetUserItemVote(const TDelegate<void(struct FGetUserItemVoteResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID);
	void GetWorkshopEULAStatus(const TDelegate<void(struct FWorkshopEULAStatus& Data, bool bWasSuccessful)>& Callback);
	void RemoveAppDependency(const TDelegate<void(struct FRemoveAppDependencyResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID, int32 AppID);
	void RemoveDependency(const TDelegate<void(struct FRemoveUGCDependencyResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& ParentPublishedFileID, const struct FPublishedFileID& ChildPublishedFileId);
	void RemoveItemFromFavorites(const TDelegate<void(struct FUserFavoriteItemsListChanged& Data, bool bWasSuccessful)>& Callback, int32 AppID, const struct FPublishedFileID& PublishedFileID);
	void SendQueryUGCRequest(const TDelegate<void(struct FSteamUGCQueryCompleted& Data, bool bWasSuccessful)>& Callback, const struct FUGCQueryHandle& Handle);
	bool SetAllowLegacyUpload(const struct FUGCUpdateHandle& Handle, bool bAllowLegacyUpload);
	void SetUserItemVote(const TDelegate<void(struct FSetUserItemVoteResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID, bool bVoteUp);
	void StartPlaytimeTracking(const TDelegate<void(struct FStartPlaytimeTrackingResult& Data, bool bWasSuccessful)>& Callback, const TArray<struct FPublishedFileID>& PublishedFileID);
	void StopPlaytimeTracking(const TDelegate<void(struct FStopPlaytimeTrackingResult& Data, bool bWasSuccessful)>& Callback, const TArray<struct FPublishedFileID>& PublishedFileIDs);
	void StopPlaytimeTrackingForAllItems(const TDelegate<void(struct FStopPlaytimeTrackingResult& Data, bool bWasSuccessful)>& Callback);
	void SubmitItemUpdate(const TDelegate<void(struct FSubmitItemUpdateResult& Data, bool bWasSuccessful)>& Callback, const struct FUGCUpdateHandle& Handle, const class FString& ChangeNote);
	void SubscribeItem(const TDelegate<void(struct FRemoteStorageSubscribePublishedFileResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID);
	void UnsubscribeItem(const TDelegate<void(struct FRemoteStorageSubscribePublishedFileResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProUGC">();
	}
	static class USteamProUGC* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProUGC>();
	}
};
static_assert(alignof(USteamProUGC) == 0x000008, "Wrong alignment on USteamProUGC");
static_assert(sizeof(USteamProUGC) == 0x0000E8, "Wrong size on USteamProUGC");
static_assert(offsetof(USteamProUGC, ItemInstalled) == 0x000028, "Member 'USteamProUGC::ItemInstalled' has a wrong offset!");
static_assert(offsetof(USteamProUGC, DownloadItemResult) == 0x000038, "Member 'USteamProUGC::DownloadItemResult' has a wrong offset!");
static_assert(offsetof(USteamProUGC, UserSubscribedItemsListChanged) == 0x000048, "Member 'USteamProUGC::UserSubscribedItemsListChanged' has a wrong offset!");
static_assert(offsetof(USteamProUGC, WorkshopEULAStatus) == 0x000058, "Member 'USteamProUGC::WorkshopEULAStatus' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems* StopPlaytimeTrackingForAllItemsAsync(class UObject* WorldContextObject, float Timeout);

	void HandleCallback(const struct FStopPlaytimeTrackingResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems">();
	}
	static class USteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems");
static_assert(sizeof(USteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems");
static_assert(offsetof(USteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionStopPlaytimeTracking
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionStopPlaytimeTracking final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionStopPlaytimeTracking* StopPlaytimeTrackingAsync(class UObject* WorldContextObject, const TArray<struct FPublishedFileID>& PublishedFileIDs, float Timeout);

	void HandleCallback(const struct FStopPlaytimeTrackingResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionStopPlaytimeTracking">();
	}
	static class USteamCoreProUGCAsyncActionStopPlaytimeTracking* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionStopPlaytimeTracking>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionStopPlaytimeTracking) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionStopPlaytimeTracking");
static_assert(sizeof(USteamCoreProUGCAsyncActionStopPlaytimeTracking) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionStopPlaytimeTracking");
static_assert(offsetof(USteamCoreProUGCAsyncActionStopPlaytimeTracking, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionStopPlaytimeTracking::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionStartPlaytimeTracking
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionStartPlaytimeTracking final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionStartPlaytimeTracking* StartPlaytimeTrackingAsync(class UObject* WorldContextObject, const TArray<struct FPublishedFileID>& PublishedFileIDs, float Timeout);

	void HandleCallback(const struct FStartPlaytimeTrackingResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionStartPlaytimeTracking">();
	}
	static class USteamCoreProUGCAsyncActionStartPlaytimeTracking* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionStartPlaytimeTracking>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionStartPlaytimeTracking) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionStartPlaytimeTracking");
static_assert(sizeof(USteamCoreProUGCAsyncActionStartPlaytimeTracking) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionStartPlaytimeTracking");
static_assert(offsetof(USteamCoreProUGCAsyncActionStartPlaytimeTracking, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionStartPlaytimeTracking::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionUnsubscribeItem
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionUnsubscribeItem final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionUnsubscribeItem* UnsubscribeItemAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileIDs, float Timeout);

	void HandleCallback(const struct FRemoteStorageSubscribePublishedFileResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionUnsubscribeItem">();
	}
	static class USteamCoreProUGCAsyncActionUnsubscribeItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionUnsubscribeItem>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionUnsubscribeItem) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionUnsubscribeItem");
static_assert(sizeof(USteamCoreProUGCAsyncActionUnsubscribeItem) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionUnsubscribeItem");
static_assert(offsetof(USteamCoreProUGCAsyncActionUnsubscribeItem, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionUnsubscribeItem::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionSubscribeItem
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionSubscribeItem final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionSubscribeItem* SubscribeItemAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileIDs, float Timeout);

	void HandleCallback(const struct FRemoteStorageSubscribePublishedFileResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionSubscribeItem">();
	}
	static class USteamCoreProUGCAsyncActionSubscribeItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionSubscribeItem>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionSubscribeItem) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionSubscribeItem");
static_assert(sizeof(USteamCoreProUGCAsyncActionSubscribeItem) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionSubscribeItem");
static_assert(offsetof(USteamCoreProUGCAsyncActionSubscribeItem, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionSubscribeItem::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionRemoveItemFromFavorites
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionRemoveItemFromFavorites final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionRemoveItemFromFavorites* RemoveItemFromFavoritesAsync(class UObject* WorldContextObject, int32 AppID, const struct FPublishedFileID& PublishedFileID, float Timeout);

	void HandleCallback(const struct FUserFavoriteItemsListChanged& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionRemoveItemFromFavorites">();
	}
	static class USteamCoreProUGCAsyncActionRemoveItemFromFavorites* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionRemoveItemFromFavorites>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionRemoveItemFromFavorites) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionRemoveItemFromFavorites");
static_assert(sizeof(USteamCoreProUGCAsyncActionRemoveItemFromFavorites) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionRemoveItemFromFavorites");
static_assert(offsetof(USteamCoreProUGCAsyncActionRemoveItemFromFavorites, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionRemoveItemFromFavorites::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionAddItemToFavorites
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionAddItemToFavorites final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionAddItemToFavorites* AddItemToFavoritesAsync(class UObject* WorldContextObject, int32 AppID, const struct FPublishedFileID& PublishedFileID, float Timeout);

	void HandleCallback(const struct FUserFavoriteItemsListChanged& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionAddItemToFavorites">();
	}
	static class USteamCoreProUGCAsyncActionAddItemToFavorites* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionAddItemToFavorites>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionAddItemToFavorites) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionAddItemToFavorites");
static_assert(sizeof(USteamCoreProUGCAsyncActionAddItemToFavorites) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionAddItemToFavorites");
static_assert(offsetof(USteamCoreProUGCAsyncActionAddItemToFavorites, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionAddItemToFavorites::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionGetUserItemVote
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionGetUserItemVote final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionGetUserItemVote* GetUserItemVoteAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, float Timeout);

	void HandleCallback(const struct FGetUserItemVoteResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionGetUserItemVote">();
	}
	static class USteamCoreProUGCAsyncActionGetUserItemVote* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionGetUserItemVote>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionGetUserItemVote) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionGetUserItemVote");
static_assert(sizeof(USteamCoreProUGCAsyncActionGetUserItemVote) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionGetUserItemVote");
static_assert(offsetof(USteamCoreProUGCAsyncActionGetUserItemVote, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionGetUserItemVote::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionSetUserItemVote
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionSetUserItemVote final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionSetUserItemVote* SetUserItemVoteAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, bool bVoteUp, float Timeout);

	void HandleCallback(const struct FSetUserItemVoteResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionSetUserItemVote">();
	}
	static class USteamCoreProUGCAsyncActionSetUserItemVote* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionSetUserItemVote>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionSetUserItemVote) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionSetUserItemVote");
static_assert(sizeof(USteamCoreProUGCAsyncActionSetUserItemVote) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionSetUserItemVote");
static_assert(offsetof(USteamCoreProUGCAsyncActionSetUserItemVote, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionSetUserItemVote::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionSubmitItemUpdate
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionSubmitItemUpdate final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionSubmitItemUpdate* SubmitItemUpdateAsync(class UObject* WorldContextObject, const struct FUGCUpdateHandle& Handle, const class FString& ChangeNote, float Timeout);

	void HandleCallback(const struct FSubmitItemUpdateResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionSubmitItemUpdate">();
	}
	static class USteamCoreProUGCAsyncActionSubmitItemUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionSubmitItemUpdate>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionSubmitItemUpdate) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionSubmitItemUpdate");
static_assert(sizeof(USteamCoreProUGCAsyncActionSubmitItemUpdate) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionSubmitItemUpdate");
static_assert(offsetof(USteamCoreProUGCAsyncActionSubmitItemUpdate, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionSubmitItemUpdate::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionCreateItem
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionCreateItem final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionCreateItem* CreateItemAsync(class UObject* WorldContextObject, int32 ConsumerAppID, ESteamWorkshopFileType FileType, float Timeout);

	void HandleCallback(const struct FCreateItemResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionCreateItem">();
	}
	static class USteamCoreProUGCAsyncActionCreateItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionCreateItem>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionCreateItem) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionCreateItem");
static_assert(sizeof(USteamCoreProUGCAsyncActionCreateItem) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionCreateItem");
static_assert(offsetof(USteamCoreProUGCAsyncActionCreateItem, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionCreateItem::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionSendQueryUGCRequest
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionSendQueryUGCRequest final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionSendQueryUGCRequest* SendQueryUGCRequestAsync(class UObject* WorldContextObject, const struct FUGCQueryHandle& Handle, float Timeout);

	void HandleCallback(const struct FSteamUGCQueryCompleted& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionSendQueryUGCRequest">();
	}
	static class USteamCoreProUGCAsyncActionSendQueryUGCRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionSendQueryUGCRequest>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionSendQueryUGCRequest) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionSendQueryUGCRequest");
static_assert(sizeof(USteamCoreProUGCAsyncActionSendQueryUGCRequest) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionSendQueryUGCRequest");
static_assert(offsetof(USteamCoreProUGCAsyncActionSendQueryUGCRequest, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionSendQueryUGCRequest::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionAddAppDependency
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionAddAppDependency final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionAddAppDependency* AddAppDependencyAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, int32 AppID, float Timeout);

	void HandleCallback(const struct FAddAppDependencyResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionAddAppDependency">();
	}
	static class USteamCoreProUGCAsyncActionAddAppDependency* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionAddAppDependency>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionAddAppDependency) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionAddAppDependency");
static_assert(sizeof(USteamCoreProUGCAsyncActionAddAppDependency) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionAddAppDependency");
static_assert(offsetof(USteamCoreProUGCAsyncActionAddAppDependency, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionAddAppDependency::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionRemoveAppDependency
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionRemoveAppDependency final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionRemoveAppDependency* RemoveAppDependencyAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, int32 AppID, float Timeout);

	void HandleCallback(const struct FRemoveAppDependencyResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionRemoveAppDependency">();
	}
	static class USteamCoreProUGCAsyncActionRemoveAppDependency* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionRemoveAppDependency>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionRemoveAppDependency) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionRemoveAppDependency");
static_assert(sizeof(USteamCoreProUGCAsyncActionRemoveAppDependency) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionRemoveAppDependency");
static_assert(offsetof(USteamCoreProUGCAsyncActionRemoveAppDependency, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionRemoveAppDependency::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionAddUGCDependency
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionAddUGCDependency final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionAddUGCDependency* AddDependencyAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, const struct FPublishedFileID& ChildPublishedFileId, float Timeout);

	void HandleCallback(const struct FAddUGCDependencyResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionAddUGCDependency">();
	}
	static class USteamCoreProUGCAsyncActionAddUGCDependency* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionAddUGCDependency>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionAddUGCDependency) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionAddUGCDependency");
static_assert(sizeof(USteamCoreProUGCAsyncActionAddUGCDependency) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionAddUGCDependency");
static_assert(offsetof(USteamCoreProUGCAsyncActionAddUGCDependency, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionAddUGCDependency::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionRemoveUGCDependency
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionRemoveUGCDependency final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionRemoveUGCDependency* RemoveDependencyAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, const struct FPublishedFileID& ChildPublishedFileId, float Timeout);

	void HandleCallback(const struct FRemoveUGCDependencyResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionRemoveUGCDependency">();
	}
	static class USteamCoreProUGCAsyncActionRemoveUGCDependency* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionRemoveUGCDependency>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionRemoveUGCDependency) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionRemoveUGCDependency");
static_assert(sizeof(USteamCoreProUGCAsyncActionRemoveUGCDependency) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionRemoveUGCDependency");
static_assert(offsetof(USteamCoreProUGCAsyncActionRemoveUGCDependency, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionRemoveUGCDependency::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionDeleteItem
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionDeleteItem final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionDeleteItem* DeleteItemAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, float Timeout);

	void HandleCallback(const struct FUGCDeleteItemResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionDeleteItem">();
	}
	static class USteamCoreProUGCAsyncActionDeleteItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionDeleteItem>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionDeleteItem) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionDeleteItem");
static_assert(sizeof(USteamCoreProUGCAsyncActionDeleteItem) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionDeleteItem");
static_assert(offsetof(USteamCoreProUGCAsyncActionDeleteItem, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionDeleteItem::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionGetAppDependencies
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionGetAppDependencies final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionGetAppDependencies* GetAppDependenciesAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, float Timeout);

	void HandleCallback(const struct FGetAppDependenciesResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionGetAppDependencies">();
	}
	static class USteamCoreProUGCAsyncActionGetAppDependencies* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionGetAppDependencies>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionGetAppDependencies) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionGetAppDependencies");
static_assert(sizeof(USteamCoreProUGCAsyncActionGetAppDependencies) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionGetAppDependencies");
static_assert(offsetof(USteamCoreProUGCAsyncActionGetAppDependencies, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionGetAppDependencies::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUGCAsyncActionDownloadItem
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUGCAsyncActionDownloadItem final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUGCAsyncActionDownloadItem* DownloadItemAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, bool bHighPriority, float Timeout);

	void HandleCallback(const struct FDownloadItemResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUGCAsyncActionDownloadItem">();
	}
	static class USteamCoreProUGCAsyncActionDownloadItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUGCAsyncActionDownloadItem>();
	}
};
static_assert(alignof(USteamCoreProUGCAsyncActionDownloadItem) == 0x000008, "Wrong alignment on USteamCoreProUGCAsyncActionDownloadItem");
static_assert(sizeof(USteamCoreProUGCAsyncActionDownloadItem) == 0x000040, "Wrong size on USteamCoreProUGCAsyncActionDownloadItem");
static_assert(offsetof(USteamCoreProUGCAsyncActionDownloadItem, OnCallback) == 0x000030, "Member 'USteamCoreProUGCAsyncActionDownloadItem::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamProUser
// 0x0240 (0x0268 - 0x0028)
class USteamProUser final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             ClientGameServerDeny;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameWebCallback;                                   // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetAuthSessionTicketResponse;                      // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             IPCFailure;                                        // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LicensesUpdated;                                   // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             MicroTxnAuthorizationResponse;                     // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamServerConnectFailure;                         // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamServersConnected;                             // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamServersDisconnected;                          // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ValidateAuthTicketResponse;                        // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EncryptedAppTicketResponse;                        // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetTicketForWebApiResponse;                        // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_238F[0x180];                                   // 0x00E8(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AdvertiseGame(const struct FSteamID& SteamIDGameServer, const class FString& ServerIP, int32 ServerPort);
	static ESteamBeginAuthSessionResult BeginAuthSession(const TArray<uint8>& Ticket, const struct FSteamID& SteamID);
	static bool BIsBehindNAT();
	static bool BIsPhoneIdentifying();
	static bool BIsPhoneRequiringVerification();
	static bool BIsPhoneVerified();
	static bool BIsTwoFactorEnabled();
	static bool BLoggedOn();
	static void CancelAuthTicket(const struct FSteamTicketHandle& TicketHandle);
	static ESteamVoiceResult DecompressVoice(const TArray<uint8>& CompressedBuffer, int32 DesiredSampleRate, TArray<uint8>* DestBuffer);
	static void EndAuthSession(const struct FSteamID& SteamID);
	static struct FSteamTicketHandle GetAuthSessionTicket(TArray<uint8>* Ticket, const struct FSteamNetworkingIdentity& SteamNetworkingIdentity);
	static struct FSteamTicketHandle GetAuthTicketForWebApi(const class FString& Identity);
	static ESteamVoiceResult GetAvailableVoice(int32* CompressedBytes, int32* UncompressedBytes, int32 UncompressedVoiceDesiredSampleRate);
	static bool GetEncryptedAppTicket(TArray<uint8>* Ticket);
	static int32 GetGameBadgeLevel(int32 Series, bool bFoil);
	static int32 GetPlayerSteamLevel();
	static struct FSteamID GetSteamID();
	static struct FSteamID GetSteamID_Pure();
	static class USteamProUser* GetSteamUser();
	static ESteamVoiceResult GetVoice(TArray<uint8>* DestBuffer, int32* BytesWritten);
	static int32 GetVoiceOptimalSampleRate();
	static void StartVoiceRecording();
	static void StopVoiceRecording();
	static ESteamUserHasLicenseForAppResult UserHasLicenseForApp(const struct FSteamID& SteamID, int32 AppID);

	void RequestEncryptedAppTicket(const TDelegate<void(struct FEncryptedAppTicketResponse& Data, bool bWasSuccessful)>& Callback, const TArray<uint8>& DataToInclude);
	void RequestStoreAuthURL(const TDelegate<void(struct FStoreAuthURLResponse& Data, bool bWasSuccessful)>& Callback, const class FString& RedirectURL);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProUser">();
	}
	static class USteamProUser* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProUser>();
	}
};
static_assert(alignof(USteamProUser) == 0x000008, "Wrong alignment on USteamProUser");
static_assert(sizeof(USteamProUser) == 0x000268, "Wrong size on USteamProUser");
static_assert(offsetof(USteamProUser, ClientGameServerDeny) == 0x000028, "Member 'USteamProUser::ClientGameServerDeny' has a wrong offset!");
static_assert(offsetof(USteamProUser, GameWebCallback) == 0x000038, "Member 'USteamProUser::GameWebCallback' has a wrong offset!");
static_assert(offsetof(USteamProUser, GetAuthSessionTicketResponse) == 0x000048, "Member 'USteamProUser::GetAuthSessionTicketResponse' has a wrong offset!");
static_assert(offsetof(USteamProUser, IPCFailure) == 0x000058, "Member 'USteamProUser::IPCFailure' has a wrong offset!");
static_assert(offsetof(USteamProUser, LicensesUpdated) == 0x000068, "Member 'USteamProUser::LicensesUpdated' has a wrong offset!");
static_assert(offsetof(USteamProUser, MicroTxnAuthorizationResponse) == 0x000078, "Member 'USteamProUser::MicroTxnAuthorizationResponse' has a wrong offset!");
static_assert(offsetof(USteamProUser, SteamServerConnectFailure) == 0x000088, "Member 'USteamProUser::SteamServerConnectFailure' has a wrong offset!");
static_assert(offsetof(USteamProUser, SteamServersConnected) == 0x000098, "Member 'USteamProUser::SteamServersConnected' has a wrong offset!");
static_assert(offsetof(USteamProUser, SteamServersDisconnected) == 0x0000A8, "Member 'USteamProUser::SteamServersDisconnected' has a wrong offset!");
static_assert(offsetof(USteamProUser, ValidateAuthTicketResponse) == 0x0000B8, "Member 'USteamProUser::ValidateAuthTicketResponse' has a wrong offset!");
static_assert(offsetof(USteamProUser, EncryptedAppTicketResponse) == 0x0000C8, "Member 'USteamProUser::EncryptedAppTicketResponse' has a wrong offset!");
static_assert(offsetof(USteamProUser, GetTicketForWebApiResponse) == 0x0000D8, "Member 'USteamProUser::GetTicketForWebApiResponse' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUserAsyncActionRequestEncryptedAppTicket
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUserAsyncActionRequestEncryptedAppTicket final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUserAsyncActionRequestEncryptedAppTicket* RequestEncryptedAppTicketAsync(class UObject* WorldContextObject, const TArray<uint8>& DataToInclude, float Timeout);

	void HandleCallback(const struct FEncryptedAppTicketResponse& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUserAsyncActionRequestEncryptedAppTicket">();
	}
	static class USteamCoreProUserAsyncActionRequestEncryptedAppTicket* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUserAsyncActionRequestEncryptedAppTicket>();
	}
};
static_assert(alignof(USteamCoreProUserAsyncActionRequestEncryptedAppTicket) == 0x000008, "Wrong alignment on USteamCoreProUserAsyncActionRequestEncryptedAppTicket");
static_assert(sizeof(USteamCoreProUserAsyncActionRequestEncryptedAppTicket) == 0x000040, "Wrong size on USteamCoreProUserAsyncActionRequestEncryptedAppTicket");
static_assert(offsetof(USteamCoreProUserAsyncActionRequestEncryptedAppTicket, OnCallback) == 0x000030, "Member 'USteamCoreProUserAsyncActionRequestEncryptedAppTicket::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUserAsyncActionRequestStoreAuthURL
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUserAsyncActionRequestStoreAuthURL final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUserAsyncActionRequestStoreAuthURL* RequestStoreAuthURLAsync(class UObject* WorldContextObject, const class FString& RedirectURL, float Timeout);

	void HandleCallback(const struct FStoreAuthURLResponse& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUserAsyncActionRequestStoreAuthURL">();
	}
	static class USteamCoreProUserAsyncActionRequestStoreAuthURL* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUserAsyncActionRequestStoreAuthURL>();
	}
};
static_assert(alignof(USteamCoreProUserAsyncActionRequestStoreAuthURL) == 0x000008, "Wrong alignment on USteamCoreProUserAsyncActionRequestStoreAuthURL");
static_assert(sizeof(USteamCoreProUserAsyncActionRequestStoreAuthURL) == 0x000040, "Wrong size on USteamCoreProUserAsyncActionRequestStoreAuthURL");
static_assert(offsetof(USteamCoreProUserAsyncActionRequestStoreAuthURL, OnCallback) == 0x000030, "Member 'USteamCoreProUserAsyncActionRequestStoreAuthURL::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamProUserStats
// 0x00F0 (0x0118 - 0x0028)
class USteamProUserStats final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             UserAchievementIconFetched;                        // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserAchievementStored;                             // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserStatsReceived;                                 // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserStatsStored;                                   // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserStatsUnloaded;                                 // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_239E[0xA0];                                    // 0x0078(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool ClearAchievement(const class FString& Param_Name);
	static bool GetAchievement(const class FString& Param_Name, bool* bAchieved);
	static bool GetAchievementAchievedPercent(const class FString& Param_Name, float* Percent);
	static bool GetAchievementAndUnlockTime(const class FString& Param_Name, bool* bAchieved, int32* UnlockTime);
	static class FString GetAchievementDisplayAttribute(const class FString& Param_Name, const class FString& Key);
	static class UTexture2D* GetAchievementIcon(const class FString& Param_Name);
	static class FString GetAchievementName(int32 Achievement);
	static bool GetAchievementProgressLimits(const class FString& Param_Name, int32* MinProgress, int32* MaxProgress);
	static bool GetAchievementProgressLimitsFloat(const class FString& Param_Name, float* MinProgress, float* MaxProgress);
	static bool GetDownloadedLeaderboardEntry(const struct FSteamLeaderboardEntries& LeaderboardEntries, int32 Param_Index, struct FSteamLeaderboardEntry* LeaderboardEntry, const TArray<int32>& Details, TArray<int32>* OutDetails);
	static bool GetGlobalStatFloat(const class FString& StatName, float* Data);
	static int32 GetGlobalStatHistoryFloat(const class FString& StatName, int32 HistoryDays, TArray<float>* Data);
	static int32 GetGlobalStatHistoryInt(const class FString& StatName, int32 HistoryDays, TArray<int32>* Data);
	static bool GetGlobalStatInt(const class FString& StatName, int32* Data);
	static ESteamLeaderboardDisplayType GetLeaderboardDisplayType(const struct FSteamLeaderboard& SteamLeaderboard);
	static int32 GetLeaderboardEntryCount(const struct FSteamLeaderboard& SteamLeaderboard);
	static class FString GetLeaderboardName(const struct FSteamLeaderboard& SteamLeaderboard);
	static ESteamLeaderboardSortMethod GetLeaderboardSortMethod(const struct FSteamLeaderboard& SteamLeaderboard);
	static int32 GetMostAchievedAchievementInfo(class FString* Param_Name, float* Percent, bool* bAchieved);
	static int32 GetNextMostAchievedAchievementInfo(int32 IteratorPrevious, class FString* Param_Name, float* Percent, bool* bAchieved);
	static int32 GetNumAchievements();
	static bool GetStatFloat(const class FString& Param_Name, float* Data);
	static bool GetStatInt(const class FString& Param_Name, int32* Data);
	static class USteamProUserStats* GetSteamUserStats();
	static bool GetUserAchievement(const struct FSteamID& SteamIDUser, const class FString& Param_Name, bool* bAchieved);
	static bool GetUserAchievementAndUnlockTime(const struct FSteamID& SteamIDUser, const class FString& Param_Name, bool* bAchieved, int32* UnlockTime);
	static bool GetUserStatFloat(const struct FSteamID& SteamIDUser, const class FString& Param_Name, float* Data);
	static bool GetUserStatInteger(const struct FSteamID& SteamIDUser, const class FString& Param_Name, int32* Data);
	static bool IndicateAchievementProgress(const class FString& Param_Name, int32 CurrentProgress, int32 MaxProgress);
	static bool RequestCurrentStats();
	static bool ResetAllStats(bool bAchievementsToo);
	static bool SetAchievement(const class FString& Param_Name);
	static bool SetStatFloat(const class FString& Param_Name, float Data);
	static bool SetStatInt(const class FString& Param_Name, int32 Data);
	static bool StoreStats();
	static bool UpdateAvgRateStat(const class FString& Param_Name, float CountThisSession, float SessionLength);

	void AttachLeaderboardUGC(const TDelegate<void(struct FAttachLeaderboardUGCData& Data, bool bWasSuccessful)>& Callback, const struct FSteamLeaderboard& SteamLeaderboard, const struct FSteamUGCHandle& Handle);
	void DownloadLeaderboardEntries(const TDelegate<void(struct FLeaderboardScoresDownloaded& Data, bool bWasSuccessful)>& Callback, const struct FSteamLeaderboard& SteamLeaderboard, ESteamLeaderboardDataRequest DataRequest, int32 RangeStart, int32 RangeEnd);
	void DownloadLeaderboardEntriesForUsers(const TDelegate<void(struct FLeaderboardScoresDownloadedForUsers& Data, bool bWasSuccessful)>& Callback, const struct FSteamLeaderboard& SteamLeaderboard, const TArray<struct FSteamID>& Users);
	void FindLeaderboard(const TDelegate<void(struct FLeaderboardFindResult& Data, bool bWasSuccessful)>& Callback, const class FString& LeaderboardName);
	void FindOrCreateLeaderboard(const TDelegate<void(struct FFindOrCreateLeaderboardData& Data, bool bWasSuccessful)>& Callback, const class FString& LeaderboardName, ESteamLeaderboardSortMethod SortMethod, ESteamLeaderboardDisplayType DisplayType);
	void GetNumberOfCurrentPlayers(const TDelegate<void(struct FNumberOfCurrentPlayers& Data, bool bWasSuccessful)>& Callback);
	void RequestGlobalAchievementPercentages(const TDelegate<void(struct FGlobalAchievementPercentagesReady& Data, bool bWasSuccessful)>& Callback);
	void RequestGlobalStats(const TDelegate<void(struct FGlobalStatsReceived& Data, bool bWasSuccessful)>& Callback, int32 HistoryDays);
	void RequestUserStats(const TDelegate<void(struct FRequestUserStatsData& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamID);
	void UploadLeaderboardScore(const TDelegate<void(struct FLeaderboardScoreUploaded& Data, bool bWasSuccessful)>& Callback, const struct FSteamLeaderboard& SteamLeaderboard, ESteamLeaderboardUploadScoreMethod UploadScoreMethod, int32 Score, const TArray<int32>& ScoreDetails);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProUserStats">();
	}
	static class USteamProUserStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProUserStats>();
	}
};
static_assert(alignof(USteamProUserStats) == 0x000008, "Wrong alignment on USteamProUserStats");
static_assert(sizeof(USteamProUserStats) == 0x000118, "Wrong size on USteamProUserStats");
static_assert(offsetof(USteamProUserStats, UserAchievementIconFetched) == 0x000028, "Member 'USteamProUserStats::UserAchievementIconFetched' has a wrong offset!");
static_assert(offsetof(USteamProUserStats, UserAchievementStored) == 0x000038, "Member 'USteamProUserStats::UserAchievementStored' has a wrong offset!");
static_assert(offsetof(USteamProUserStats, UserStatsReceived) == 0x000048, "Member 'USteamProUserStats::UserStatsReceived' has a wrong offset!");
static_assert(offsetof(USteamProUserStats, UserStatsStored) == 0x000058, "Member 'USteamProUserStats::UserStatsStored' has a wrong offset!");
static_assert(offsetof(USteamProUserStats, UserStatsUnloaded) == 0x000068, "Member 'USteamProUserStats::UserStatsUnloaded' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUserStatsAsyncActionFindLeaderboard
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUserStatsAsyncActionFindLeaderboard final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUserStatsAsyncActionFindLeaderboard* FindLeaderboardAsync(class UObject* WorldContextObject, const class FString& LeaderboardName, float Timeout);

	void HandleCallback(const struct FLeaderboardFindResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUserStatsAsyncActionFindLeaderboard">();
	}
	static class USteamCoreProUserStatsAsyncActionFindLeaderboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUserStatsAsyncActionFindLeaderboard>();
	}
};
static_assert(alignof(USteamCoreProUserStatsAsyncActionFindLeaderboard) == 0x000008, "Wrong alignment on USteamCoreProUserStatsAsyncActionFindLeaderboard");
static_assert(sizeof(USteamCoreProUserStatsAsyncActionFindLeaderboard) == 0x000040, "Wrong size on USteamCoreProUserStatsAsyncActionFindLeaderboard");
static_assert(offsetof(USteamCoreProUserStatsAsyncActionFindLeaderboard, OnCallback) == 0x000030, "Member 'USteamCoreProUserStatsAsyncActionFindLeaderboard::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries* DownloadLeaderboardEntriesAsync(class UObject* WorldContextObject, const struct FSteamLeaderboard& SteamLeaderboard, ESteamLeaderboardDataRequest Request, int32 RangeStart, int32 RangeEnd, float Timeout);

	void HandleCallback(const struct FLeaderboardScoresDownloaded& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries">();
	}
	static class USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries>();
	}
};
static_assert(alignof(USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries) == 0x000008, "Wrong alignment on USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries");
static_assert(sizeof(USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries) == 0x000040, "Wrong size on USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries");
static_assert(offsetof(USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries, OnCallback) == 0x000030, "Member 'USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats* RequestGlobalStatsAsync(class UObject* WorldContextObject, int32 HistoryDays, float Timeout);

	void HandleCallback(const struct FGlobalStatsReceived& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats">();
	}
	static class USteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats>();
	}
};
static_assert(alignof(USteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats) == 0x000008, "Wrong alignment on USteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats");
static_assert(sizeof(USteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats) == 0x000040, "Wrong size on USteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats");
static_assert(offsetof(USteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats, OnCallback) == 0x000030, "Member 'USteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages* RequestGlobalAchievementPercentagesAsync(class UObject* WorldContextObject, float Timeout);

	void HandleCallback(const struct FGlobalAchievementPercentagesReady& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages">();
	}
	static class USteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages>();
	}
};
static_assert(alignof(USteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages) == 0x000008, "Wrong alignment on USteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages");
static_assert(sizeof(USteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages) == 0x000040, "Wrong size on USteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages");
static_assert(offsetof(USteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages, OnCallback) == 0x000030, "Member 'USteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers* GetNumberOfCurrentPlayersAsync(class UObject* WorldContextObject, float Timeout);

	void HandleCallback(const struct FNumberOfCurrentPlayers& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers">();
	}
	static class USteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers>();
	}
};
static_assert(alignof(USteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers) == 0x000008, "Wrong alignment on USteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers");
static_assert(sizeof(USteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers) == 0x000040, "Wrong size on USteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers");
static_assert(offsetof(USteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers, OnCallback) == 0x000030, "Member 'USteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUserStatsAsyncActionUploadLeaderboardScore
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUserStatsAsyncActionUploadLeaderboardScore final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUserStatsAsyncActionUploadLeaderboardScore* UploadLeaderboardScoreAsync(class UObject* WorldContextObject, const struct FSteamLeaderboard& SteamLeaderboard, ESteamLeaderboardUploadScoreMethod UploadScoreMethod, int32 Score, const TArray<int32>& ScoreDetails, float Timeout);

	void HandleCallback(const struct FLeaderboardScoreUploaded& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUserStatsAsyncActionUploadLeaderboardScore">();
	}
	static class USteamCoreProUserStatsAsyncActionUploadLeaderboardScore* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUserStatsAsyncActionUploadLeaderboardScore>();
	}
};
static_assert(alignof(USteamCoreProUserStatsAsyncActionUploadLeaderboardScore) == 0x000008, "Wrong alignment on USteamCoreProUserStatsAsyncActionUploadLeaderboardScore");
static_assert(sizeof(USteamCoreProUserStatsAsyncActionUploadLeaderboardScore) == 0x000040, "Wrong size on USteamCoreProUserStatsAsyncActionUploadLeaderboardScore");
static_assert(offsetof(USteamCoreProUserStatsAsyncActionUploadLeaderboardScore, OnCallback) == 0x000030, "Member 'USteamCoreProUserStatsAsyncActionUploadLeaderboardScore::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard* FindOrCreateLeaderboardAsync(class UObject* WorldContextObject, const class FString& LeaderboardName, ESteamLeaderboardSortMethod SortMethod, ESteamLeaderboardDisplayType DisplayType, float Timeout);

	void HandleCallback(const struct FFindOrCreateLeaderboardData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard">();
	}
	static class USteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard>();
	}
};
static_assert(alignof(USteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard) == 0x000008, "Wrong alignment on USteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard");
static_assert(sizeof(USteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard) == 0x000040, "Wrong size on USteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard");
static_assert(offsetof(USteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard, OnCallback) == 0x000030, "Member 'USteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUserStatsAsyncActionRequestUserStats
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUserStatsAsyncActionRequestUserStats final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUserStatsAsyncActionRequestUserStats* RequestUserStatsAsync(class UObject* WorldContextObject, const struct FSteamID& SteamID, float Timeout);

	void HandleCallback(const struct FRequestUserStatsData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUserStatsAsyncActionRequestUserStats">();
	}
	static class USteamCoreProUserStatsAsyncActionRequestUserStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUserStatsAsyncActionRequestUserStats>();
	}
};
static_assert(alignof(USteamCoreProUserStatsAsyncActionRequestUserStats) == 0x000008, "Wrong alignment on USteamCoreProUserStatsAsyncActionRequestUserStats");
static_assert(sizeof(USteamCoreProUserStatsAsyncActionRequestUserStats) == 0x000040, "Wrong size on USteamCoreProUserStatsAsyncActionRequestUserStats");
static_assert(offsetof(USteamCoreProUserStatsAsyncActionRequestUserStats, OnCallback) == 0x000030, "Member 'USteamCoreProUserStatsAsyncActionRequestUserStats::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUserStatsAsyncActionRequestCurrentStats
// 0x0030 (0x0060 - 0x0030)
class USteamCoreProUserStatsAsyncActionRequestCurrentStats final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D7[0x20];                                    // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamCoreProUserStatsAsyncActionRequestCurrentStats* RequestCurrentStatsAsync(class UObject* WorldContextObject, float Timeout);

	void HandleCallback(const struct FRequestCurrentStatsData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUserStatsAsyncActionRequestCurrentStats">();
	}
	static class USteamCoreProUserStatsAsyncActionRequestCurrentStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUserStatsAsyncActionRequestCurrentStats>();
	}
};
static_assert(alignof(USteamCoreProUserStatsAsyncActionRequestCurrentStats) == 0x000008, "Wrong alignment on USteamCoreProUserStatsAsyncActionRequestCurrentStats");
static_assert(sizeof(USteamCoreProUserStatsAsyncActionRequestCurrentStats) == 0x000060, "Wrong size on USteamCoreProUserStatsAsyncActionRequestCurrentStats");
static_assert(offsetof(USteamCoreProUserStatsAsyncActionRequestCurrentStats, OnCallback) == 0x000030, "Member 'USteamCoreProUserStatsAsyncActionRequestCurrentStats::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers* DownloadLeaderboardEntriesForUsersAsync(class UObject* WorldContextObject, const struct FSteamLeaderboard& SteamLeaderboard, const TArray<struct FSteamID>& Users, float Timeout);

	void HandleCallback(const struct FLeaderboardScoresDownloadedForUsers& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers">();
	}
	static class USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers>();
	}
};
static_assert(alignof(USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers) == 0x000008, "Wrong alignment on USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers");
static_assert(sizeof(USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers) == 0x000040, "Wrong size on USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers");
static_assert(offsetof(USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers, OnCallback) == 0x000030, "Member 'USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProUserStatsAsyncActionAttachLeaderboardUGC
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProUserStatsAsyncActionAttachLeaderboardUGC final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProUserStatsAsyncActionAttachLeaderboardUGC* AttachLeaderboardUGCAsync(class UObject* WorldContextObject, const struct FSteamLeaderboard& SteamLeaderboard, const struct FSteamUGCHandle& Handle, float Timeout);

	void HandleCallback(const struct FAttachLeaderboardUGCData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProUserStatsAsyncActionAttachLeaderboardUGC">();
	}
	static class USteamCoreProUserStatsAsyncActionAttachLeaderboardUGC* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProUserStatsAsyncActionAttachLeaderboardUGC>();
	}
};
static_assert(alignof(USteamCoreProUserStatsAsyncActionAttachLeaderboardUGC) == 0x000008, "Wrong alignment on USteamCoreProUserStatsAsyncActionAttachLeaderboardUGC");
static_assert(sizeof(USteamCoreProUserStatsAsyncActionAttachLeaderboardUGC) == 0x000040, "Wrong size on USteamCoreProUserStatsAsyncActionAttachLeaderboardUGC");
static_assert(offsetof(USteamCoreProUserStatsAsyncActionAttachLeaderboardUGC, OnCallback) == 0x000030, "Member 'USteamCoreProUserStatsAsyncActionAttachLeaderboardUGC::OnCallback' has a wrong offset!");

// Class SteamCorePro.SteamCoreProVoice
// 0x0000 (0x0480 - 0x0480)
class USteamCoreProVoice final : public USoundWaveProcedural
{
public:
	static class USteamCoreProVoice* ConstructSteamCoreProVoice(int32 AudioSampleRate);
	static void DestroySteamCoreProVoice(class USteamCoreProVoice* Obj);

	void AddAudioBuffer(const TArray<uint8>& Buffer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProVoice">();
	}
	static class USteamCoreProVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProVoice>();
	}
};
static_assert(alignof(USteamCoreProVoice) == 0x000008, "Wrong alignment on USteamCoreProVoice");
static_assert(sizeof(USteamCoreProVoice) == 0x000480, "Wrong size on USteamCoreProVoice");

// Class SteamCorePro.SteamCoreProAsyncActionListenForControllerChange
// 0x0010 (0x0040 - 0x0030)
class USteamCoreProAsyncActionListenForControllerChange final : public USteamCoreProAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnControllerChanged;                               // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreProAsyncActionListenForControllerChange* ListenForControllerChange(class UObject* WorldContextObject);

	void HandleCallback(bool bIsConnected, int32 PlatformUserId, int32 UserId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreProAsyncActionListenForControllerChange">();
	}
	static class USteamCoreProAsyncActionListenForControllerChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreProAsyncActionListenForControllerChange>();
	}
};
static_assert(alignof(USteamCoreProAsyncActionListenForControllerChange) == 0x000008, "Wrong alignment on USteamCoreProAsyncActionListenForControllerChange");
static_assert(sizeof(USteamCoreProAsyncActionListenForControllerChange) == 0x000040, "Wrong size on USteamCoreProAsyncActionListenForControllerChange");
static_assert(offsetof(USteamCoreProAsyncActionListenForControllerChange, OnControllerChanged) == 0x000030, "Member 'USteamCoreProAsyncActionListenForControllerChange::OnControllerChanged' has a wrong offset!");

// Class SteamCorePro.SteamUtilities
// 0x0000 (0x0028 - 0x0028)
class USteamUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class FString BP_BytesToString(const TArray<uint8>& Array);
	static TArray<uint8> BP_StringToBytes(const class FString& String);
	static class FString BreakInventoryUpdateHandle(const struct FSteamInventoryUpdateHandle& Handle);
	static class FString BreakPublishedFileID(const struct FPublishedFileID& FileID);
	static class FString BreakSteamGameID(const struct FSteamGameID& SteamID);
	static class FString BreakSteamID(const struct FSteamID& SteamID);
	static class FString BreakTicketHandle(const struct FSteamTicketHandle& Handle);
	static class FString BreakUGCHandle(const struct FSteamUGCHandle& Handle);
	static class UServerFilter* ConstructServerFilter(class UObject* WorldContextObject);
	static class FString EncryptString(const class FString& String);
	static bool Equal(const struct FSteamID& A, const struct FSteamID& B);
	static void Equal_Exec(const struct FSteamID& A, const struct FSteamID& B, ESteamCoreProIdentical* Result);
	static struct FDateTime FromUnixTimestamp(const class FString& Timestamp);
	static ESteamAccountType GetAccountType(const struct FSteamID& SteamID);
	static TArray<struct FOnlineFriendSteamCoreBlueprint> GetFriendsList(EFriendListType FriendListType);
	static bool GetGameEngineInitialized();
	static class FString GetHostPingData();
	static bool GetInteger(const struct FSteamSessionSetting& Settings, class FString* Key, int32* OutValue);
	static int32 GetPingFromHostData(const class FString& Data);
	static void GetPublicIp(const TDelegate<void(const class FString& Response)>& Callback);
	static struct FSteamID GetSteamIdFromPlayerState(class APlayerState* PlayerState);
	static bool GetString(const struct FSteamSessionSetting& Settings, class FString* Key, class FString* OutValue);
	static ESteamAttributeType GetType(const struct FSteamSessionSetting& Settings);
	static bool IsGameIDValid(const struct FSteamGameID& GameId);
	static void IsGameIDValid_Exec(const struct FSteamGameID& GameId, ESteamCoreProValid* Result);
	static bool IsLobby(const struct FSteamID& SteamID);
	static bool IsLocalPlayerTalking(class UObject* WorldContextObject, int32 LocalUserNum);
	static bool IsPlayerMuted(class UObject* WorldContextObject, class APlayerState* Player);
	static bool IsPublishedFileIDValid(const struct FPublishedFileID& PublishedFileID);
	static void IsPublishedFileIDValid_Exec(const struct FPublishedFileID& Handle, ESteamCoreProValid* Result);
	static bool IsRecalculatingPing();
	static bool IsRemotePlayerTalking(class UObject* WorldContextObject, class APlayerState* Player);
	static bool IsSteamAvailable();
	static void IsSteamIDValid_Exec(const struct FSteamID& SteamID, ESteamCoreProValid* Result);
	static bool IsSteamInventoryUpdateHandleValid(const struct FSteamInventoryUpdateHandle& Handle);
	static void IsSteamInventoryUpdateHandleValid_Exec(const struct FSteamInventoryUpdateHandle& Handle, ESteamCoreProValid* Result);
	static bool IsSteamServerInitialized();
	static bool IsSteamTicketHandleValid(const struct FSteamTicketHandle& Handle);
	static void IsSteamTicketHandleValid_Exec(const struct FSteamTicketHandle& Handle, ESteamCoreProValid* Result);
	static bool IsUGCHandleValid(const struct FSteamUGCHandle& Handle);
	static void IsUGCHandleValid_Exec(const struct FSteamUGCHandle& Handle, ESteamCoreProValid* Result);
	static bool IsUsingP2PRelays();
	static bool IsValid(const struct FSteamID& SteamID);
	static TArray<uint8> K2_HexToBytes(const class FString& String);
	static class FString K2_HexToString(const TArray<uint8>& Array);
	static bool K2_IsPlayerInSession(int32 LocalUserNum);
	static bool KickPlayer(class UObject* WorldContextObject, class APlayerController* KickedPlayer, const class FText& KickReason);
	static void ListenForSessionInviteAccepted(const TDelegate<void(bool bWasSuccessful, int32 LocalPlayerNum, const class FString& InvitedBy, struct FBlueprintSessionResult& Session)>& Callback);
	static void ListenForSteamMessages(const TDelegate<void(ESteamMessageType Type, const class FString& Message)>& Callback);
	static struct FSteamSessionSetting MakeInteger(const int32 Value);
	static struct FSteamInventoryUpdateHandle MakeInventoryUpdateHandle(const class FString& Value);
	static struct FPublishedFileID MakePublishedFileID(const class FString& Value);
	static struct FSteamSessionSearchSetting MakeSearchInteger(const ESteamComparisonOp ComparisonOperator, const int32 Value);
	static struct FSteamSessionSearchSetting MakeSearchString(const class FString& Value);
	static struct FSteamGameID MakeSteamGameID(const class FString& Value);
	static struct FSteamID MakeSteamID(const class FString& Value);
	static struct FSteamSessionSetting MakeString(const class FString& Value);
	static struct FSteamTicketHandle MakeTicketHandle(const class FString& Value);
	static struct FSteamUGCHandle MakeUGCHandle(const class FString& Value);
	static bool MuteRemoteTalker(class UObject* WorldContextObject, int32 LocalUserNum, class APlayerState* PlayerState, bool bIsSystemWide);
	static bool NotEqual(const struct FSteamID& A, const struct FSteamID& B);
	static bool PublishedFileID_Equals(const struct FPublishedFileID& A, const struct FPublishedFileID& B);
	static void PublishedFileID_Equals_Exec(const struct FPublishedFileID& A, const struct FPublishedFileID& B, ESteamCoreProIdentical* Result);
	static bool PublishedFileID_NotEquals(const struct FPublishedFileID& A, const struct FPublishedFileID& B);
	static TArray<uint8> ReadFileToBytes(const class FString& AbsoluteFilePath);
	static void ReadFriendList(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, EFriendListType FriendListType);
	static void SetLocalHost(struct FSteamNetworkingIdentity& SteamNetworkingIdentity);
	static void SetPSNId(struct FSteamNetworkingIdentity& SteamNetworkingIdentity, int64 ID);
	static void SetStadiaId(struct FSteamNetworkingIdentity& SteamNetworkingIdentity, int64 ID);
	static void SetSteamId64(struct FSteamNetworkingIdentity& SteamNetworkingIdentity, const struct FSteamID& SteamID);
	static void SetType(struct FSteamNetworkingIdentity& SteamNetworkingIdentity, ESteamCoreNetworkingIdentityType Type);
	static void SetXboxPairwiseId(struct FSteamNetworkingIdentity& SteamNetworkingIdentity, const class FString& String);
	static bool SteamItemInstanceID_Equals(const struct FSteamItemInstanceID& A, const struct FSteamItemInstanceID& B);
	static void SteamItemInstanceID_Equals_Exec(const struct FSteamItemInstanceID& A, const struct FSteamItemInstanceID& B, ESteamCoreProIdentical* Result);
	static void StopListeningForSessionInviteAccepted();
	static bool TryJoinServer(class FString* OutErrorMessage, const class UObject* WorldContextObject, const struct FSteamServerAddr& ServerAddr, class APlayerController* SpecificPlayer, bool bUsingSockets);
	static bool UnmuteRemoteTalker(class UObject* WorldContextObject, int32 LocalUserNum, class APlayerState* PlayerState, bool bIsSystemWide);
	static bool WriteBytesToFile(bool bOverwriteIfExists, const class FString& AbsoluteFilePath, const TArray<uint8>& DataBuffer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamUtilities">();
	}
	static class USteamUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamUtilities>();
	}
};
static_assert(alignof(USteamUtilities) == 0x000008, "Wrong alignment on USteamUtilities");
static_assert(sizeof(USteamUtilities) == 0x000028, "Wrong size on USteamUtilities");

// Class SteamCorePro.SteamProUtils
// 0x0150 (0x0178 - 0x0028)
class USteamProUtils final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             CheckFileSignature;                                // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GamepadTextInputDismissed;                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             IPCountry;                                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LowBatteryPower;                                   // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamShutdown;                                     // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AppResumingFromSuspend;                            // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FloatingGamepadTextInputDismissed;                 // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_240C[0xE0];                                    // 0x0098(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool BOverlayNeedsPresent();
	static bool DismissFloatingGamepadTextInput();
	static bool DismissGamepadTextInput();
	static int32 GetAppID();
	static int32 GetAppID_Pure();
	static ESteamUniverse GetConnectedUniverse();
	static int32 GetCurrentBatteryPower();
	static bool GetEnteredGamepadTextInput(class FString* Text);
	static int32 GetEnteredGamepadTextLength();
	static bool GetImageRGBA(int32 IImage, TArray<uint8>* OutBuffer);
	static bool GetImageSize(int32 IImage, int32* Width, int32* Height);
	static int32 GetIPCCallCount();
	static class FString GetIPCountry();
	static ESteamCoreIPv6ConnectivityState GetIPv6ConnectivityState(ESteamCoreIPv6ConnectivityProtocol Protocol);
	static int32 GetSecondsSinceAppActive();
	static int32 GetSecondsSinceComputerActive();
	static int32 GetServerRealTime();
	static class FString GetSteamUILanguage();
	static class USteamProUtils* GetSteamUtils();
	static bool InitFilterText();
	static bool IsOverlayEnabled();
	static bool IsSteamChinaLauncher();
	static bool IsSteamInBigPictureMode();
	static bool IsSteamRunningInVR();
	static bool IsVRHeadsetStreamingEnabled();
	static void SetGameLauncherMode(bool bLauncherMode);
	static void SetOverlayNotificationInset(int32 HorizontalInset, int32 VerticalInset);
	static void SetOverlayNotificationPosition(ESteamNotificationPosition NotificationPosition);
	static void SetVRHeadsetStreamingEnabled(bool bEnabled);
	static bool ShowFloatingGamepadTextInput(ESteamFloatingGamepadTextInputMode KeyboardMode, int32 TextFieldXPosition, int32 TextFieldYPosition, int32 TextFieldWidth, int32 TextFieldHeight);
	static bool ShowGamepadTextInput(ESteamGamepadTextInputMode InputMode, ESteamGamepadTextInputLineMode LineInputMode, const class FString& Description, int32 CharMax, const class FString& ExistingText);
	static void StartVRDashboard();

	bool IsSteamRunningOnSteamDeck();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProUtils">();
	}
	static class USteamProUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProUtils>();
	}
};
static_assert(alignof(USteamProUtils) == 0x000008, "Wrong alignment on USteamProUtils");
static_assert(sizeof(USteamProUtils) == 0x000178, "Wrong size on USteamProUtils");
static_assert(offsetof(USteamProUtils, CheckFileSignature) == 0x000028, "Member 'USteamProUtils::CheckFileSignature' has a wrong offset!");
static_assert(offsetof(USteamProUtils, GamepadTextInputDismissed) == 0x000038, "Member 'USteamProUtils::GamepadTextInputDismissed' has a wrong offset!");
static_assert(offsetof(USteamProUtils, IPCountry) == 0x000048, "Member 'USteamProUtils::IPCountry' has a wrong offset!");
static_assert(offsetof(USteamProUtils, LowBatteryPower) == 0x000058, "Member 'USteamProUtils::LowBatteryPower' has a wrong offset!");
static_assert(offsetof(USteamProUtils, SteamShutdown) == 0x000068, "Member 'USteamProUtils::SteamShutdown' has a wrong offset!");
static_assert(offsetof(USteamProUtils, AppResumingFromSuspend) == 0x000078, "Member 'USteamProUtils::AppResumingFromSuspend' has a wrong offset!");
static_assert(offsetof(USteamProUtils, FloatingGamepadTextInputDismissed) == 0x000088, "Member 'USteamProUtils::FloatingGamepadTextInputDismissed' has a wrong offset!");

// Class SteamCorePro.SteamProVideo
// 0x0060 (0x0088 - 0x0028)
class USteamProVideo final : public USteamCoreInterface
{
public:
	FMulticastInlineDelegateProperty_             GetOPFSettingsResult;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetVideoURLResult;                                 // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2416[0x40];                                    // 0x0048(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void GetOPFSettings(int32 VideoAppID);
	static bool GetOPFStringForApp(int32 VideoAppID, class FString* OutBuffer);
	static class USteamProVideo* GetSteamVideo();
	static void GetVideoURL(int32 VideoAppID);
	static bool IsBroadcasting(int32* NumViewers);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProVideo">();
	}
	static class USteamProVideo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProVideo>();
	}
};
static_assert(alignof(USteamProVideo) == 0x000008, "Wrong alignment on USteamProVideo");
static_assert(sizeof(USteamProVideo) == 0x000088, "Wrong size on USteamProVideo");
static_assert(offsetof(USteamProVideo, GetOPFSettingsResult) == 0x000028, "Member 'USteamProVideo::GetOPFSettingsResult' has a wrong offset!");
static_assert(offsetof(USteamProVideo, GetVideoURLResult) == 0x000038, "Member 'USteamProVideo::GetVideoURLResult' has a wrong offset!");

}

