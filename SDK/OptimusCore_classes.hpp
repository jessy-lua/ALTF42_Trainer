#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OptimusCore

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "ComputeFramework_structs.hpp"
#include "ComputeFramework_classes.hpp"
#include "OptimusCore_structs.hpp"


namespace SDK
{

// Class OptimusCore.OptimusComponentBindingProvider
// 0x0000 (0x0028 - 0x0028)
class IOptimusComponentBindingProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusComponentBindingProvider">();
	}
	static class IOptimusComponentBindingProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusComponentBindingProvider>();
	}
};
static_assert(alignof(IOptimusComponentBindingProvider) == 0x000008, "Wrong alignment on IOptimusComponentBindingProvider");
static_assert(sizeof(IOptimusComponentBindingProvider) == 0x000028, "Wrong size on IOptimusComponentBindingProvider");

// Class OptimusCore.OptimusComputeKernelProvider
// 0x0000 (0x0028 - 0x0028)
class IOptimusComputeKernelProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusComputeKernelProvider">();
	}
	static class IOptimusComputeKernelProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusComputeKernelProvider>();
	}
};
static_assert(alignof(IOptimusComputeKernelProvider) == 0x000008, "Wrong alignment on IOptimusComputeKernelProvider");
static_assert(sizeof(IOptimusComputeKernelProvider) == 0x000028, "Wrong size on IOptimusComputeKernelProvider");

// Class OptimusCore.OptimusDataInterfaceProvider
// 0x0000 (0x0028 - 0x0028)
class IOptimusDataInterfaceProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDataInterfaceProvider">();
	}
	static class IOptimusDataInterfaceProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusDataInterfaceProvider>();
	}
};
static_assert(alignof(IOptimusDataInterfaceProvider) == 0x000008, "Wrong alignment on IOptimusDataInterfaceProvider");
static_assert(sizeof(IOptimusDataInterfaceProvider) == 0x000028, "Wrong size on IOptimusDataInterfaceProvider");

// Class OptimusCore.OptimusDeprecatedExecutionDataInterface
// 0x0000 (0x0028 - 0x0028)
class IOptimusDeprecatedExecutionDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDeprecatedExecutionDataInterface">();
	}
	static class IOptimusDeprecatedExecutionDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusDeprecatedExecutionDataInterface>();
	}
};
static_assert(alignof(IOptimusDeprecatedExecutionDataInterface) == 0x000008, "Wrong alignment on IOptimusDeprecatedExecutionDataInterface");
static_assert(sizeof(IOptimusDeprecatedExecutionDataInterface) == 0x000028, "Wrong size on IOptimusDeprecatedExecutionDataInterface");

// Class OptimusCore.OptimusExecutionDomainProvider
// 0x0000 (0x0028 - 0x0028)
class IOptimusExecutionDomainProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusExecutionDomainProvider">();
	}
	static class IOptimusExecutionDomainProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusExecutionDomainProvider>();
	}
};
static_assert(alignof(IOptimusExecutionDomainProvider) == 0x000008, "Wrong alignment on IOptimusExecutionDomainProvider");
static_assert(sizeof(IOptimusExecutionDomainProvider) == 0x000028, "Wrong size on IOptimusExecutionDomainProvider");

// Class OptimusCore.OptimusGeneratedClassDefiner
// 0x0000 (0x0028 - 0x0028)
class IOptimusGeneratedClassDefiner final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusGeneratedClassDefiner">();
	}
	static class IOptimusGeneratedClassDefiner* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusGeneratedClassDefiner>();
	}
};
static_assert(alignof(IOptimusGeneratedClassDefiner) == 0x000008, "Wrong alignment on IOptimusGeneratedClassDefiner");
static_assert(sizeof(IOptimusGeneratedClassDefiner) == 0x000028, "Wrong size on IOptimusGeneratedClassDefiner");

// Class OptimusCore.OptimusNodeAdderPinProvider
// 0x0000 (0x0028 - 0x0028)
class IOptimusNodeAdderPinProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodeAdderPinProvider">();
	}
	static class IOptimusNodeAdderPinProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusNodeAdderPinProvider>();
	}
};
static_assert(alignof(IOptimusNodeAdderPinProvider) == 0x000008, "Wrong alignment on IOptimusNodeAdderPinProvider");
static_assert(sizeof(IOptimusNodeAdderPinProvider) == 0x000028, "Wrong size on IOptimusNodeAdderPinProvider");

// Class OptimusCore.OptimusNodeFunctionLibraryOwner
// 0x0000 (0x0028 - 0x0028)
class IOptimusNodeFunctionLibraryOwner final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodeFunctionLibraryOwner">();
	}
	static class IOptimusNodeFunctionLibraryOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusNodeFunctionLibraryOwner>();
	}
};
static_assert(alignof(IOptimusNodeFunctionLibraryOwner) == 0x000008, "Wrong alignment on IOptimusNodeFunctionLibraryOwner");
static_assert(sizeof(IOptimusNodeFunctionLibraryOwner) == 0x000028, "Wrong size on IOptimusNodeFunctionLibraryOwner");

// Class OptimusCore.OptimusNodeGraphCollectionOwner
// 0x0000 (0x0028 - 0x0028)
class IOptimusNodeGraphCollectionOwner final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodeGraphCollectionOwner">();
	}
	static class IOptimusNodeGraphCollectionOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusNodeGraphCollectionOwner>();
	}
};
static_assert(alignof(IOptimusNodeGraphCollectionOwner) == 0x000008, "Wrong alignment on IOptimusNodeGraphCollectionOwner");
static_assert(sizeof(IOptimusNodeGraphCollectionOwner) == 0x000028, "Wrong size on IOptimusNodeGraphCollectionOwner");

// Class OptimusCore.OptimusNodePinRouter
// 0x0000 (0x0028 - 0x0028)
class IOptimusNodePinRouter final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodePinRouter">();
	}
	static class IOptimusNodePinRouter* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusNodePinRouter>();
	}
};
static_assert(alignof(IOptimusNodePinRouter) == 0x000008, "Wrong alignment on IOptimusNodePinRouter");
static_assert(sizeof(IOptimusNodePinRouter) == 0x000028, "Wrong size on IOptimusNodePinRouter");

// Class OptimusCore.OptimusParameterBindingProvider
// 0x0000 (0x0028 - 0x0028)
class IOptimusParameterBindingProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusParameterBindingProvider">();
	}
	static class IOptimusParameterBindingProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusParameterBindingProvider>();
	}
};
static_assert(alignof(IOptimusParameterBindingProvider) == 0x000008, "Wrong alignment on IOptimusParameterBindingProvider");
static_assert(sizeof(IOptimusParameterBindingProvider) == 0x000028, "Wrong size on IOptimusParameterBindingProvider");

// Class OptimusCore.OptimusPathResolver
// 0x0000 (0x0028 - 0x0028)
class IOptimusPathResolver final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusPathResolver">();
	}
	static class IOptimusPathResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusPathResolver>();
	}
};
static_assert(alignof(IOptimusPathResolver) == 0x000008, "Wrong alignment on IOptimusPathResolver");
static_assert(sizeof(IOptimusPathResolver) == 0x000028, "Wrong size on IOptimusPathResolver");

// Class OptimusCore.OptimusShaderTextProvider
// 0x0000 (0x0028 - 0x0028)
class IOptimusShaderTextProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusShaderTextProvider">();
	}
	static class IOptimusShaderTextProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusShaderTextProvider>();
	}
};
static_assert(alignof(IOptimusShaderTextProvider) == 0x000008, "Wrong alignment on IOptimusShaderTextProvider");
static_assert(sizeof(IOptimusShaderTextProvider) == 0x000028, "Wrong size on IOptimusShaderTextProvider");

// Class OptimusCore.OptimusValueProvider
// 0x0000 (0x0028 - 0x0028)
class IOptimusValueProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusValueProvider">();
	}
	static class IOptimusValueProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOptimusValueProvider>();
	}
};
static_assert(alignof(IOptimusValueProvider) == 0x000008, "Wrong alignment on IOptimusValueProvider");
static_assert(sizeof(IOptimusValueProvider) == 0x000028, "Wrong size on IOptimusValueProvider");

// Class OptimusCore.OptimusComputeDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusComputeDataInterface : public UComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusComputeDataInterface">();
	}
	static class UOptimusComputeDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusComputeDataInterface>();
	}
};
static_assert(alignof(UOptimusComputeDataInterface) == 0x000008, "Wrong alignment on UOptimusComputeDataInterface");
static_assert(sizeof(UOptimusComputeDataInterface) == 0x000028, "Wrong size on UOptimusComputeDataInterface");

// Class OptimusCore.OptimusSkinnedMeshVertexAttributeDataInterface
// 0x0008 (0x0030 - 0x0028)
class UOptimusSkinnedMeshVertexAttributeDataInterface final : public UOptimusComputeDataInterface
{
public:
	class FName                                   AttributeName;                                     // 0x0028(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshVertexAttributeDataInterface">();
	}
	static class UOptimusSkinnedMeshVertexAttributeDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshVertexAttributeDataInterface>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshVertexAttributeDataInterface) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshVertexAttributeDataInterface");
static_assert(sizeof(UOptimusSkinnedMeshVertexAttributeDataInterface) == 0x000030, "Wrong size on UOptimusSkinnedMeshVertexAttributeDataInterface");
static_assert(offsetof(UOptimusSkinnedMeshVertexAttributeDataInterface, AttributeName) == 0x000028, "Member 'UOptimusSkinnedMeshVertexAttributeDataInterface::AttributeName' has a wrong offset!");

// Class OptimusCore.OptimusSkinnedMeshVertexAttributeDataProvider
// 0x0010 (0x0038 - 0x0028)
class UOptimusSkinnedMeshVertexAttributeDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMeshComponent;                              // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttributeName;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshVertexAttributeDataProvider">();
	}
	static class UOptimusSkinnedMeshVertexAttributeDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshVertexAttributeDataProvider>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshVertexAttributeDataProvider) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshVertexAttributeDataProvider");
static_assert(sizeof(UOptimusSkinnedMeshVertexAttributeDataProvider) == 0x000038, "Wrong size on UOptimusSkinnedMeshVertexAttributeDataProvider");
static_assert(offsetof(UOptimusSkinnedMeshVertexAttributeDataProvider, SkinnedMeshComponent) == 0x000028, "Member 'UOptimusSkinnedMeshVertexAttributeDataProvider::SkinnedMeshComponent' has a wrong offset!");
static_assert(offsetof(UOptimusSkinnedMeshVertexAttributeDataProvider, AttributeName) == 0x000030, "Member 'UOptimusSkinnedMeshVertexAttributeDataProvider::AttributeName' has a wrong offset!");

// Class OptimusCore.OptimusKernelSource
// 0x0010 (0x00A8 - 0x0098)
class UOptimusKernelSource final : public UComputeKernelSource
{
public:
	class FString                                 Source;                                            // 0x0098(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusKernelSource">();
	}
	static class UOptimusKernelSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusKernelSource>();
	}
};
static_assert(alignof(UOptimusKernelSource) == 0x000008, "Wrong alignment on UOptimusKernelSource");
static_assert(sizeof(UOptimusKernelSource) == 0x0000A8, "Wrong size on UOptimusKernelSource");
static_assert(offsetof(UOptimusKernelSource, Source) == 0x000098, "Member 'UOptimusKernelSource::Source' has a wrong offset!");

// Class OptimusCore.OptimusComponentSource
// 0x0000 (0x0028 - 0x0028)
class UOptimusComponentSource : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusComponentSource">();
	}
	static class UOptimusComponentSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusComponentSource>();
	}
};
static_assert(alignof(UOptimusComponentSource) == 0x000008, "Wrong alignment on UOptimusComponentSource");
static_assert(sizeof(UOptimusComponentSource) == 0x000028, "Wrong size on UOptimusComponentSource");

// Class OptimusCore.OptimusSceneComponentSource
// 0x0000 (0x0028 - 0x0028)
class UOptimusSceneComponentSource final : public UOptimusComponentSource
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSceneComponentSource">();
	}
	static class UOptimusSceneComponentSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSceneComponentSource>();
	}
};
static_assert(alignof(UOptimusSceneComponentSource) == 0x000008, "Wrong alignment on UOptimusSceneComponentSource");
static_assert(sizeof(UOptimusSceneComponentSource) == 0x000028, "Wrong size on UOptimusSceneComponentSource");

// Class OptimusCore.OptimusSkinnedMeshComponentSource
// 0x0000 (0x0028 - 0x0028)
class UOptimusSkinnedMeshComponentSource : public UOptimusComponentSource
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshComponentSource">();
	}
	static class UOptimusSkinnedMeshComponentSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshComponentSource>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshComponentSource) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshComponentSource");
static_assert(sizeof(UOptimusSkinnedMeshComponentSource) == 0x000028, "Wrong size on UOptimusSkinnedMeshComponentSource");

// Class OptimusCore.OptimusSkeletalMeshComponentSource
// 0x0000 (0x0028 - 0x0028)
class UOptimusSkeletalMeshComponentSource final : public UOptimusSkinnedMeshComponentSource
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkeletalMeshComponentSource">();
	}
	static class UOptimusSkeletalMeshComponentSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkeletalMeshComponentSource>();
	}
};
static_assert(alignof(UOptimusSkeletalMeshComponentSource) == 0x000008, "Wrong alignment on UOptimusSkeletalMeshComponentSource");
static_assert(sizeof(UOptimusSkeletalMeshComponentSource) == 0x000028, "Wrong size on UOptimusSkeletalMeshComponentSource");

// Class OptimusCore.OptimusAnimAttributeDataInterface
// 0x0010 (0x0038 - 0x0028)
class UOptimusAnimAttributeDataInterface final : public UOptimusComputeDataInterface
{
public:
	struct FOptimusAnimAttributeArray             AttributeArray;                                    // 0x0028(0x0010)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusAnimAttributeDataInterface">();
	}
	static class UOptimusAnimAttributeDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusAnimAttributeDataInterface>();
	}
};
static_assert(alignof(UOptimusAnimAttributeDataInterface) == 0x000008, "Wrong alignment on UOptimusAnimAttributeDataInterface");
static_assert(sizeof(UOptimusAnimAttributeDataInterface) == 0x000038, "Wrong size on UOptimusAnimAttributeDataInterface");
static_assert(offsetof(UOptimusAnimAttributeDataInterface, AttributeArray) == 0x000028, "Member 'UOptimusAnimAttributeDataInterface::AttributeArray' has a wrong offset!");

// Class OptimusCore.OptimusAnimAttributeDataProvider
// 0x0020 (0x0048 - 0x0028)
class UOptimusAnimAttributeDataProvider final : public UComputeDataProvider
{
public:
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A7B[0x18];                                    // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusAnimAttributeDataProvider">();
	}
	static class UOptimusAnimAttributeDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusAnimAttributeDataProvider>();
	}
};
static_assert(alignof(UOptimusAnimAttributeDataProvider) == 0x000008, "Wrong alignment on UOptimusAnimAttributeDataProvider");
static_assert(sizeof(UOptimusAnimAttributeDataProvider) == 0x000048, "Wrong size on UOptimusAnimAttributeDataProvider");
static_assert(offsetof(UOptimusAnimAttributeDataProvider, SkeletalMesh) == 0x000028, "Member 'UOptimusAnimAttributeDataProvider::SkeletalMesh' has a wrong offset!");

// Class OptimusCore.OptimusClothDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusClothDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusClothDataInterface">();
	}
	static class UOptimusClothDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusClothDataInterface>();
	}
};
static_assert(alignof(UOptimusClothDataInterface) == 0x000008, "Wrong alignment on UOptimusClothDataInterface");
static_assert(sizeof(UOptimusClothDataInterface) == 0x000028, "Wrong size on UOptimusClothDataInterface");

// Class OptimusCore.OptimusClothDataProvider
// 0x0008 (0x0030 - 0x0028)
class UOptimusClothDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusClothDataProvider">();
	}
	static class UOptimusClothDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusClothDataProvider>();
	}
};
static_assert(alignof(UOptimusClothDataProvider) == 0x000008, "Wrong alignment on UOptimusClothDataProvider");
static_assert(sizeof(UOptimusClothDataProvider) == 0x000030, "Wrong size on UOptimusClothDataProvider");
static_assert(offsetof(UOptimusClothDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusClothDataProvider::SkinnedMesh' has a wrong offset!");

// Class OptimusCore.OptimusConnectivityDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusConnectivityDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusConnectivityDataInterface">();
	}
	static class UOptimusConnectivityDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusConnectivityDataInterface>();
	}
};
static_assert(alignof(UOptimusConnectivityDataInterface) == 0x000008, "Wrong alignment on UOptimusConnectivityDataInterface");
static_assert(sizeof(UOptimusConnectivityDataInterface) == 0x000028, "Wrong size on UOptimusConnectivityDataInterface");

// Class OptimusCore.OptimusConnectivityDataProvider
// 0x0018 (0x0040 - 0x0028)
class UOptimusConnectivityDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A7C[0x10];                                    // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusConnectivityDataProvider">();
	}
	static class UOptimusConnectivityDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusConnectivityDataProvider>();
	}
};
static_assert(alignof(UOptimusConnectivityDataProvider) == 0x000008, "Wrong alignment on UOptimusConnectivityDataProvider");
static_assert(sizeof(UOptimusConnectivityDataProvider) == 0x000040, "Wrong size on UOptimusConnectivityDataProvider");
static_assert(offsetof(UOptimusConnectivityDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusConnectivityDataProvider::SkinnedMesh' has a wrong offset!");

// Class OptimusCore.OptimusCustomComputeKernelDataInterface
// 0x0018 (0x0040 - 0x0028)
class UOptimusCustomComputeKernelDataInterface final : public UComputeDataInterface
{
public:
	TWeakObjectPtr<class UOptimusComponentSourceBinding> ComponentSourceBinding;                            // 0x0028(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NumThreadsExpression;                              // 0x0030(0x0010)(BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusCustomComputeKernelDataInterface">();
	}
	static class UOptimusCustomComputeKernelDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusCustomComputeKernelDataInterface>();
	}
};
static_assert(alignof(UOptimusCustomComputeKernelDataInterface) == 0x000008, "Wrong alignment on UOptimusCustomComputeKernelDataInterface");
static_assert(sizeof(UOptimusCustomComputeKernelDataInterface) == 0x000040, "Wrong size on UOptimusCustomComputeKernelDataInterface");
static_assert(offsetof(UOptimusCustomComputeKernelDataInterface, ComponentSourceBinding) == 0x000028, "Member 'UOptimusCustomComputeKernelDataInterface::ComponentSourceBinding' has a wrong offset!");
static_assert(offsetof(UOptimusCustomComputeKernelDataInterface, NumThreadsExpression) == 0x000030, "Member 'UOptimusCustomComputeKernelDataInterface::NumThreadsExpression' has a wrong offset!");

// Class OptimusCore.OptimusCustomComputeKernelDataProvider
// 0x0010 (0x0038 - 0x0028)
class UOptimusCustomComputeKernelDataProvider final : public UComputeDataProvider
{
public:
	uint8                                         Pad_1A7D[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusCustomComputeKernelDataProvider">();
	}
	static class UOptimusCustomComputeKernelDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusCustomComputeKernelDataProvider>();
	}
};
static_assert(alignof(UOptimusCustomComputeKernelDataProvider) == 0x000008, "Wrong alignment on UOptimusCustomComputeKernelDataProvider");
static_assert(sizeof(UOptimusCustomComputeKernelDataProvider) == 0x000038, "Wrong size on UOptimusCustomComputeKernelDataProvider");

// Class OptimusCore.OptimusDebugDrawDataInterface
// 0x0018 (0x0040 - 0x0028)
class UOptimusDebugDrawDataInterface final : public UOptimusComputeDataInterface
{
public:
	struct FOptimusDebugDrawParameters            DebugDrawParameters;                               // 0x0028(0x0014)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A7E[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDebugDrawDataInterface">();
	}
	static class UOptimusDebugDrawDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusDebugDrawDataInterface>();
	}
};
static_assert(alignof(UOptimusDebugDrawDataInterface) == 0x000008, "Wrong alignment on UOptimusDebugDrawDataInterface");
static_assert(sizeof(UOptimusDebugDrawDataInterface) == 0x000040, "Wrong size on UOptimusDebugDrawDataInterface");
static_assert(offsetof(UOptimusDebugDrawDataInterface, DebugDrawParameters) == 0x000028, "Member 'UOptimusDebugDrawDataInterface::DebugDrawParameters' has a wrong offset!");

// Class OptimusCore.OptimusDebugDrawDataProvider
// 0x0020 (0x0048 - 0x0028)
class UOptimusDebugDrawDataProvider final : public UComputeDataProvider
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusDebugDrawParameters            DebugDrawParameters;                               // 0x0030(0x0014)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A7F[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDebugDrawDataProvider">();
	}
	static class UOptimusDebugDrawDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusDebugDrawDataProvider>();
	}
};
static_assert(alignof(UOptimusDebugDrawDataProvider) == 0x000008, "Wrong alignment on UOptimusDebugDrawDataProvider");
static_assert(sizeof(UOptimusDebugDrawDataProvider) == 0x000048, "Wrong size on UOptimusDebugDrawDataProvider");
static_assert(offsetof(UOptimusDebugDrawDataProvider, PrimitiveComponent) == 0x000028, "Member 'UOptimusDebugDrawDataProvider::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(UOptimusDebugDrawDataProvider, DebugDrawParameters) == 0x000030, "Member 'UOptimusDebugDrawDataProvider::DebugDrawParameters' has a wrong offset!");

// Class OptimusCore.OptimusDuplicateVerticesDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusDuplicateVerticesDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDuplicateVerticesDataInterface">();
	}
	static class UOptimusDuplicateVerticesDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusDuplicateVerticesDataInterface>();
	}
};
static_assert(alignof(UOptimusDuplicateVerticesDataInterface) == 0x000008, "Wrong alignment on UOptimusDuplicateVerticesDataInterface");
static_assert(sizeof(UOptimusDuplicateVerticesDataInterface) == 0x000028, "Wrong size on UOptimusDuplicateVerticesDataInterface");

// Class OptimusCore.OptimusDuplicateVerticesDataProvider
// 0x0008 (0x0030 - 0x0028)
class UOptimusDuplicateVerticesDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDuplicateVerticesDataProvider">();
	}
	static class UOptimusDuplicateVerticesDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusDuplicateVerticesDataProvider>();
	}
};
static_assert(alignof(UOptimusDuplicateVerticesDataProvider) == 0x000008, "Wrong alignment on UOptimusDuplicateVerticesDataProvider");
static_assert(sizeof(UOptimusDuplicateVerticesDataProvider) == 0x000030, "Wrong size on UOptimusDuplicateVerticesDataProvider");
static_assert(offsetof(UOptimusDuplicateVerticesDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusDuplicateVerticesDataProvider::SkinnedMesh' has a wrong offset!");

// Class OptimusCore.OptimusGraphDataInterface
// 0x0018 (0x0040 - 0x0028)
class UOptimusGraphDataInterface final : public UComputeDataInterface
{
public:
	TArray<struct FOptimusGraphVariableDescription> Variables;                                         // 0x0028(0x0010)(BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         ParameterBufferSize;                               // 0x0038(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A80[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusGraphDataInterface">();
	}
	static class UOptimusGraphDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusGraphDataInterface>();
	}
};
static_assert(alignof(UOptimusGraphDataInterface) == 0x000008, "Wrong alignment on UOptimusGraphDataInterface");
static_assert(sizeof(UOptimusGraphDataInterface) == 0x000040, "Wrong size on UOptimusGraphDataInterface");
static_assert(offsetof(UOptimusGraphDataInterface, Variables) == 0x000028, "Member 'UOptimusGraphDataInterface::Variables' has a wrong offset!");
static_assert(offsetof(UOptimusGraphDataInterface, ParameterBufferSize) == 0x000038, "Member 'UOptimusGraphDataInterface::ParameterBufferSize' has a wrong offset!");

// Class OptimusCore.OptimusGraphDataProvider
// 0x0028 (0x0050 - 0x0028)
class UOptimusGraphDataProvider final : public UComputeDataProvider
{
public:
	class UMeshComponent*                         MeshComponent;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOptimusDeformerInstance*               DeformerInstance;                                  // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOptimusGraphVariableDescription> Variables;                                         // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A81[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusGraphDataProvider">();
	}
	static class UOptimusGraphDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusGraphDataProvider>();
	}
};
static_assert(alignof(UOptimusGraphDataProvider) == 0x000008, "Wrong alignment on UOptimusGraphDataProvider");
static_assert(sizeof(UOptimusGraphDataProvider) == 0x000050, "Wrong size on UOptimusGraphDataProvider");
static_assert(offsetof(UOptimusGraphDataProvider, MeshComponent) == 0x000028, "Member 'UOptimusGraphDataProvider::MeshComponent' has a wrong offset!");
static_assert(offsetof(UOptimusGraphDataProvider, DeformerInstance) == 0x000030, "Member 'UOptimusGraphDataProvider::DeformerInstance' has a wrong offset!");
static_assert(offsetof(UOptimusGraphDataProvider, Variables) == 0x000038, "Member 'UOptimusGraphDataProvider::Variables' has a wrong offset!");

// Class OptimusCore.OptimusHalfEdgeDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusHalfEdgeDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusHalfEdgeDataInterface">();
	}
	static class UOptimusHalfEdgeDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusHalfEdgeDataInterface>();
	}
};
static_assert(alignof(UOptimusHalfEdgeDataInterface) == 0x000008, "Wrong alignment on UOptimusHalfEdgeDataInterface");
static_assert(sizeof(UOptimusHalfEdgeDataInterface) == 0x000028, "Wrong size on UOptimusHalfEdgeDataInterface");

// Class OptimusCore.OptimusHalfEdgeDataProvider
// 0x0028 (0x0050 - 0x0028)
class UOptimusHalfEdgeDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A82[0x20];                                    // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusHalfEdgeDataProvider">();
	}
	static class UOptimusHalfEdgeDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusHalfEdgeDataProvider>();
	}
};
static_assert(alignof(UOptimusHalfEdgeDataProvider) == 0x000008, "Wrong alignment on UOptimusHalfEdgeDataProvider");
static_assert(sizeof(UOptimusHalfEdgeDataProvider) == 0x000050, "Wrong size on UOptimusHalfEdgeDataProvider");
static_assert(offsetof(UOptimusHalfEdgeDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusHalfEdgeDataProvider::SkinnedMesh' has a wrong offset!");

// Class OptimusCore.OptimusMorphTargetDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusMorphTargetDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusMorphTargetDataInterface">();
	}
	static class UOptimusMorphTargetDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusMorphTargetDataInterface>();
	}
};
static_assert(alignof(UOptimusMorphTargetDataInterface) == 0x000008, "Wrong alignment on UOptimusMorphTargetDataInterface");
static_assert(sizeof(UOptimusMorphTargetDataInterface) == 0x000028, "Wrong size on UOptimusMorphTargetDataInterface");

// Class OptimusCore.OptimusMorphTargetDataProvider
// 0x0008 (0x0030 - 0x0028)
class UOptimusMorphTargetDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusMorphTargetDataProvider">();
	}
	static class UOptimusMorphTargetDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusMorphTargetDataProvider>();
	}
};
static_assert(alignof(UOptimusMorphTargetDataProvider) == 0x000008, "Wrong alignment on UOptimusMorphTargetDataProvider");
static_assert(sizeof(UOptimusMorphTargetDataProvider) == 0x000030, "Wrong size on UOptimusMorphTargetDataProvider");
static_assert(offsetof(UOptimusMorphTargetDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusMorphTargetDataProvider::SkinnedMesh' has a wrong offset!");

// Class OptimusCore.OptimusRawBufferDataInterface
// 0x0050 (0x0078 - 0x0028)
class UOptimusRawBufferDataInterface : public UOptimusComputeDataInterface
{
public:
	struct FShaderValueTypeHandle                 ValueType;                                         // 0x0028(0x0008)(BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusDataDomain                     DataDomain;                                        // 0x0030(0x0040)(BlueprintReadOnly, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UOptimusComponentSourceBinding> ComponentSourceBinding;                            // 0x0070(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusRawBufferDataInterface">();
	}
	static class UOptimusRawBufferDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusRawBufferDataInterface>();
	}
};
static_assert(alignof(UOptimusRawBufferDataInterface) == 0x000008, "Wrong alignment on UOptimusRawBufferDataInterface");
static_assert(sizeof(UOptimusRawBufferDataInterface) == 0x000078, "Wrong size on UOptimusRawBufferDataInterface");
static_assert(offsetof(UOptimusRawBufferDataInterface, ValueType) == 0x000028, "Member 'UOptimusRawBufferDataInterface::ValueType' has a wrong offset!");
static_assert(offsetof(UOptimusRawBufferDataInterface, DataDomain) == 0x000030, "Member 'UOptimusRawBufferDataInterface::DataDomain' has a wrong offset!");
static_assert(offsetof(UOptimusRawBufferDataInterface, ComponentSourceBinding) == 0x000070, "Member 'UOptimusRawBufferDataInterface::ComponentSourceBinding' has a wrong offset!");

// Class OptimusCore.OptimusTransientBufferDataInterface
// 0x0000 (0x0078 - 0x0078)
class UOptimusTransientBufferDataInterface final : public UOptimusRawBufferDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusTransientBufferDataInterface">();
	}
	static class UOptimusTransientBufferDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusTransientBufferDataInterface>();
	}
};
static_assert(alignof(UOptimusTransientBufferDataInterface) == 0x000008, "Wrong alignment on UOptimusTransientBufferDataInterface");
static_assert(sizeof(UOptimusTransientBufferDataInterface) == 0x000078, "Wrong size on UOptimusTransientBufferDataInterface");

// Class OptimusCore.OptimusPersistentBufferDataInterface
// 0x0008 (0x0080 - 0x0078)
class UOptimusPersistentBufferDataInterface final : public UOptimusRawBufferDataInterface
{
public:
	class FName                                   ResourceName;                                      // 0x0078(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusPersistentBufferDataInterface">();
	}
	static class UOptimusPersistentBufferDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusPersistentBufferDataInterface>();
	}
};
static_assert(alignof(UOptimusPersistentBufferDataInterface) == 0x000008, "Wrong alignment on UOptimusPersistentBufferDataInterface");
static_assert(sizeof(UOptimusPersistentBufferDataInterface) == 0x000080, "Wrong size on UOptimusPersistentBufferDataInterface");
static_assert(offsetof(UOptimusPersistentBufferDataInterface, ResourceName) == 0x000078, "Member 'UOptimusPersistentBufferDataInterface::ResourceName' has a wrong offset!");

// Class OptimusCore.OptimusRawBufferDataProvider
// 0x0058 (0x0080 - 0x0028)
class UOptimusRawBufferDataProvider : public UComputeDataProvider
{
public:
	TWeakObjectPtr<class UActorComponent>         Component;                                         // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UOptimusComponentSource> ComponentSource;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusDataDomain                     DataDomain;                                        // 0x0038(0x0040)(NativeAccessSpecifierPublic)
	int32                                         ElementStride;                                     // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RawStride;                                         // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusRawBufferDataProvider">();
	}
	static class UOptimusRawBufferDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusRawBufferDataProvider>();
	}
};
static_assert(alignof(UOptimusRawBufferDataProvider) == 0x000008, "Wrong alignment on UOptimusRawBufferDataProvider");
static_assert(sizeof(UOptimusRawBufferDataProvider) == 0x000080, "Wrong size on UOptimusRawBufferDataProvider");
static_assert(offsetof(UOptimusRawBufferDataProvider, Component) == 0x000028, "Member 'UOptimusRawBufferDataProvider::Component' has a wrong offset!");
static_assert(offsetof(UOptimusRawBufferDataProvider, ComponentSource) == 0x000030, "Member 'UOptimusRawBufferDataProvider::ComponentSource' has a wrong offset!");
static_assert(offsetof(UOptimusRawBufferDataProvider, DataDomain) == 0x000038, "Member 'UOptimusRawBufferDataProvider::DataDomain' has a wrong offset!");
static_assert(offsetof(UOptimusRawBufferDataProvider, ElementStride) == 0x000078, "Member 'UOptimusRawBufferDataProvider::ElementStride' has a wrong offset!");
static_assert(offsetof(UOptimusRawBufferDataProvider, RawStride) == 0x00007C, "Member 'UOptimusRawBufferDataProvider::RawStride' has a wrong offset!");

// Class OptimusCore.OptimusTransientBufferDataProvider
// 0x0000 (0x0080 - 0x0080)
class UOptimusTransientBufferDataProvider final : public UOptimusRawBufferDataProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusTransientBufferDataProvider">();
	}
	static class UOptimusTransientBufferDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusTransientBufferDataProvider>();
	}
};
static_assert(alignof(UOptimusTransientBufferDataProvider) == 0x000008, "Wrong alignment on UOptimusTransientBufferDataProvider");
static_assert(sizeof(UOptimusTransientBufferDataProvider) == 0x000080, "Wrong size on UOptimusTransientBufferDataProvider");

// Class OptimusCore.OptimusPersistentBufferDataProvider
// 0x0018 (0x0098 - 0x0080)
class UOptimusPersistentBufferDataProvider final : public UOptimusRawBufferDataProvider
{
public:
	uint8                                         Pad_1A83[0x18];                                    // 0x0080(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusPersistentBufferDataProvider">();
	}
	static class UOptimusPersistentBufferDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusPersistentBufferDataProvider>();
	}
};
static_assert(alignof(UOptimusPersistentBufferDataProvider) == 0x000008, "Wrong alignment on UOptimusPersistentBufferDataProvider");
static_assert(sizeof(UOptimusPersistentBufferDataProvider) == 0x000098, "Wrong size on UOptimusPersistentBufferDataProvider");

// Class OptimusCore.OptimusSceneDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusSceneDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSceneDataInterface">();
	}
	static class UOptimusSceneDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSceneDataInterface>();
	}
};
static_assert(alignof(UOptimusSceneDataInterface) == 0x000008, "Wrong alignment on UOptimusSceneDataInterface");
static_assert(sizeof(UOptimusSceneDataInterface) == 0x000028, "Wrong size on UOptimusSceneDataInterface");

// Class OptimusCore.OptimusSceneDataProvider
// 0x0008 (0x0030 - 0x0028)
class UOptimusSceneDataProvider final : public UComputeDataProvider
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSceneDataProvider">();
	}
	static class UOptimusSceneDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSceneDataProvider>();
	}
};
static_assert(alignof(UOptimusSceneDataProvider) == 0x000008, "Wrong alignment on UOptimusSceneDataProvider");
static_assert(sizeof(UOptimusSceneDataProvider) == 0x000030, "Wrong size on UOptimusSceneDataProvider");
static_assert(offsetof(UOptimusSceneDataProvider, SceneComponent) == 0x000028, "Member 'UOptimusSceneDataProvider::SceneComponent' has a wrong offset!");

// Class OptimusCore.OptimusSkeletonDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusSkeletonDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkeletonDataInterface">();
	}
	static class UOptimusSkeletonDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkeletonDataInterface>();
	}
};
static_assert(alignof(UOptimusSkeletonDataInterface) == 0x000008, "Wrong alignment on UOptimusSkeletonDataInterface");
static_assert(sizeof(UOptimusSkeletonDataInterface) == 0x000028, "Wrong size on UOptimusSkeletonDataInterface");

// Class OptimusCore.OptimusSkeletonDataProvider
// 0x0008 (0x0030 - 0x0028)
class UOptimusSkeletonDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkeletonDataProvider">();
	}
	static class UOptimusSkeletonDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkeletonDataProvider>();
	}
};
static_assert(alignof(UOptimusSkeletonDataProvider) == 0x000008, "Wrong alignment on UOptimusSkeletonDataProvider");
static_assert(sizeof(UOptimusSkeletonDataProvider) == 0x000030, "Wrong size on UOptimusSkeletonDataProvider");
static_assert(offsetof(UOptimusSkeletonDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusSkeletonDataProvider::SkinnedMesh' has a wrong offset!");

// Class OptimusCore.OptimusSkinnedMeshDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusSkinnedMeshDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshDataInterface">();
	}
	static class UOptimusSkinnedMeshDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshDataInterface>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshDataInterface) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshDataInterface");
static_assert(sizeof(UOptimusSkinnedMeshDataInterface) == 0x000028, "Wrong size on UOptimusSkinnedMeshDataInterface");

// Class OptimusCore.OptimusSkinnedMeshDataProvider
// 0x0008 (0x0030 - 0x0028)
class UOptimusSkinnedMeshDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshDataProvider">();
	}
	static class UOptimusSkinnedMeshDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshDataProvider>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshDataProvider) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshDataProvider");
static_assert(sizeof(UOptimusSkinnedMeshDataProvider) == 0x000030, "Wrong size on UOptimusSkinnedMeshDataProvider");
static_assert(offsetof(UOptimusSkinnedMeshDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusSkinnedMeshDataProvider::SkinnedMesh' has a wrong offset!");

// Class OptimusCore.OptimusSkinnedMeshExecDataInterface
// 0x0010 (0x0038 - 0x0028)
class UOptimusSkinnedMeshExecDataInterface final : public UOptimusComputeDataInterface
{
public:
	uint8                                         Pad_1A84[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EOptimusSkinnedMeshExecDomain                 Domain;                                            // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A85[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshExecDataInterface">();
	}
	static class UOptimusSkinnedMeshExecDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshExecDataInterface>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshExecDataInterface) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshExecDataInterface");
static_assert(sizeof(UOptimusSkinnedMeshExecDataInterface) == 0x000038, "Wrong size on UOptimusSkinnedMeshExecDataInterface");
static_assert(offsetof(UOptimusSkinnedMeshExecDataInterface, Domain) == 0x000030, "Member 'UOptimusSkinnedMeshExecDataInterface::Domain' has a wrong offset!");

// Class OptimusCore.OptimusSkinnedMeshExecDataProvider
// 0x0010 (0x0038 - 0x0028)
class UOptimusSkinnedMeshExecDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOptimusSkinnedMeshExecDomain                 Domain;                                            // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A86[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshExecDataProvider">();
	}
	static class UOptimusSkinnedMeshExecDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshExecDataProvider>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshExecDataProvider) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshExecDataProvider");
static_assert(sizeof(UOptimusSkinnedMeshExecDataProvider) == 0x000038, "Wrong size on UOptimusSkinnedMeshExecDataProvider");
static_assert(offsetof(UOptimusSkinnedMeshExecDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusSkinnedMeshExecDataProvider::SkinnedMesh' has a wrong offset!");
static_assert(offsetof(UOptimusSkinnedMeshExecDataProvider, Domain) == 0x000030, "Member 'UOptimusSkinnedMeshExecDataProvider::Domain' has a wrong offset!");

// Class OptimusCore.OptimusSkinnedMeshWriteDataInterface
// 0x0000 (0x0028 - 0x0028)
class UOptimusSkinnedMeshWriteDataInterface final : public UOptimusComputeDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshWriteDataInterface">();
	}
	static class UOptimusSkinnedMeshWriteDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshWriteDataInterface>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshWriteDataInterface) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshWriteDataInterface");
static_assert(sizeof(UOptimusSkinnedMeshWriteDataInterface) == 0x000028, "Wrong size on UOptimusSkinnedMeshWriteDataInterface");

// Class OptimusCore.OptimusSkinnedMeshWriteDataProvider
// 0x0010 (0x0038 - 0x0028)
class UOptimusSkinnedMeshWriteDataProvider final : public UComputeDataProvider
{
public:
	class USkinnedMeshComponent*                  SkinnedMesh;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A87[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSkinnedMeshWriteDataProvider">();
	}
	static class UOptimusSkinnedMeshWriteDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSkinnedMeshWriteDataProvider>();
	}
};
static_assert(alignof(UOptimusSkinnedMeshWriteDataProvider) == 0x000008, "Wrong alignment on UOptimusSkinnedMeshWriteDataProvider");
static_assert(sizeof(UOptimusSkinnedMeshWriteDataProvider) == 0x000038, "Wrong size on UOptimusSkinnedMeshWriteDataProvider");
static_assert(offsetof(UOptimusSkinnedMeshWriteDataProvider, SkinnedMesh) == 0x000028, "Member 'UOptimusSkinnedMeshWriteDataProvider::SkinnedMesh' has a wrong offset!");

// Class OptimusCore.OptimusNode
// 0x00E8 (0x0110 - 0x0028)
class UOptimusNode : public UObject
{
public:
	uint8                                         Pad_1A88[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(NonTransactional, NativeAccessSpecifierPrivate)
	struct FVector2D                              GraphPosition;                                     // 0x0048(0x0010)(ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UOptimusNodePin*>                Pins;                                              // 0x0058(0x0010)(ZeroConstructor, NonTransactional, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<class FName>                             ExpandedPins;                                      // 0x0068(0x0050)(NonTransactional, NativeAccessSpecifierPrivate)
	EOptimusDiagnosticLevel                       DiagnosticLevel;                                   // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A89[0x57];                                    // 0x00B9(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool SetGraphPosition(const struct FVector2D& InPosition);

	class FText GetDisplayName() const;
	struct FVector2D GetGraphPosition() const;
	class FName GetNodeCategory() const;
	class FName GetNodeName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode">();
	}
	static class UOptimusNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode>();
	}
};
static_assert(alignof(UOptimusNode) == 0x000008, "Wrong alignment on UOptimusNode");
static_assert(sizeof(UOptimusNode) == 0x000110, "Wrong size on UOptimusNode");
static_assert(offsetof(UOptimusNode, DisplayName) == 0x000030, "Member 'UOptimusNode::DisplayName' has a wrong offset!");
static_assert(offsetof(UOptimusNode, GraphPosition) == 0x000048, "Member 'UOptimusNode::GraphPosition' has a wrong offset!");
static_assert(offsetof(UOptimusNode, Pins) == 0x000058, "Member 'UOptimusNode::Pins' has a wrong offset!");
static_assert(offsetof(UOptimusNode, ExpandedPins) == 0x000068, "Member 'UOptimusNode::ExpandedPins' has a wrong offset!");
static_assert(offsetof(UOptimusNode, DiagnosticLevel) == 0x0000B8, "Member 'UOptimusNode::DiagnosticLevel' has a wrong offset!");

// Class OptimusCore.OptimusNode_DataInterface
// 0x0018 (0x0128 - 0x0110)
class UOptimusNode_DataInterface : public UOptimusNode
{
public:
	uint8                                         Pad_1A8B[0x8];                                     // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UObject>                    DataInterfaceClass;                                // 0x0118(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOptimusComputeDataInterface*           DataInterfaceData;                                 // 0x0120(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_DataInterface">();
	}
	static class UOptimusNode_DataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_DataInterface>();
	}
};
static_assert(alignof(UOptimusNode_DataInterface) == 0x000008, "Wrong alignment on UOptimusNode_DataInterface");
static_assert(sizeof(UOptimusNode_DataInterface) == 0x000128, "Wrong size on UOptimusNode_DataInterface");
static_assert(offsetof(UOptimusNode_DataInterface, DataInterfaceClass) == 0x000118, "Member 'UOptimusNode_DataInterface::DataInterfaceClass' has a wrong offset!");
static_assert(offsetof(UOptimusNode_DataInterface, DataInterfaceData) == 0x000120, "Member 'UOptimusNode_DataInterface::DataInterfaceData' has a wrong offset!");

// Class OptimusCore.OptimusNode_AnimAttributeDataInterface
// 0x0000 (0x0128 - 0x0128)
class UOptimusNode_AnimAttributeDataInterface final : public UOptimusNode_DataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_AnimAttributeDataInterface">();
	}
	static class UOptimusNode_AnimAttributeDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_AnimAttributeDataInterface>();
	}
};
static_assert(alignof(UOptimusNode_AnimAttributeDataInterface) == 0x000008, "Wrong alignment on UOptimusNode_AnimAttributeDataInterface");
static_assert(sizeof(UOptimusNode_AnimAttributeDataInterface) == 0x000128, "Wrong size on UOptimusNode_AnimAttributeDataInterface");

// Class OptimusCore.OptimusNode_ComponentSource
// 0x0010 (0x0120 - 0x0110)
class UOptimusNode_ComponentSource final : public UOptimusNode
{
public:
	uint8                                         Pad_1A8C[0x8];                                     // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOptimusComponentSourceBinding*         Binding;                                           // 0x0118(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_ComponentSource">();
	}
	static class UOptimusNode_ComponentSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_ComponentSource>();
	}
};
static_assert(alignof(UOptimusNode_ComponentSource) == 0x000008, "Wrong alignment on UOptimusNode_ComponentSource");
static_assert(sizeof(UOptimusNode_ComponentSource) == 0x000120, "Wrong size on UOptimusNode_ComponentSource");
static_assert(offsetof(UOptimusNode_ComponentSource, Binding) == 0x000118, "Member 'UOptimusNode_ComponentSource::Binding' has a wrong offset!");

// Class OptimusCore.OptimusNode_ComputeKernelBase
// 0x0008 (0x0118 - 0x0110)
class UOptimusNode_ComputeKernelBase : public UOptimusNode
{
public:
	uint8                                         Pad_1A8D[0x8];                                     // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_ComputeKernelBase">();
	}
	static class UOptimusNode_ComputeKernelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_ComputeKernelBase>();
	}
};
static_assert(alignof(UOptimusNode_ComputeKernelBase) == 0x000008, "Wrong alignment on UOptimusNode_ComputeKernelBase");
static_assert(sizeof(UOptimusNode_ComputeKernelBase) == 0x000118, "Wrong size on UOptimusNode_ComputeKernelBase");

// Class OptimusCore.OptimusNode_ComputeKernelFunctionGeneratorClass
// 0x0058 (0x0258 - 0x0200)
class UOptimusNode_ComputeKernelFunctionGeneratorClass final : public UClass
{
public:
	class FName                                   Category;                                          // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KernelName;                                        // 0x0208(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusExecutionDomain                ExecutionDomain;                                   // 0x0210(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FIntVector                             GroupSize;                                         // 0x0218(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8E[0x4];                                     // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOptimusParameterBinding>       InputBindings;                                     // 0x0228(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOptimusParameterBinding>       OutputBindings;                                    // 0x0238(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 ShaderSource;                                      // 0x0248(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_ComputeKernelFunctionGeneratorClass">();
	}
	static class UOptimusNode_ComputeKernelFunctionGeneratorClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_ComputeKernelFunctionGeneratorClass>();
	}
};
static_assert(alignof(UOptimusNode_ComputeKernelFunctionGeneratorClass) == 0x000008, "Wrong alignment on UOptimusNode_ComputeKernelFunctionGeneratorClass");
static_assert(sizeof(UOptimusNode_ComputeKernelFunctionGeneratorClass) == 0x000258, "Wrong size on UOptimusNode_ComputeKernelFunctionGeneratorClass");
static_assert(offsetof(UOptimusNode_ComputeKernelFunctionGeneratorClass, Category) == 0x000200, "Member 'UOptimusNode_ComputeKernelFunctionGeneratorClass::Category' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ComputeKernelFunctionGeneratorClass, KernelName) == 0x000208, "Member 'UOptimusNode_ComputeKernelFunctionGeneratorClass::KernelName' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ComputeKernelFunctionGeneratorClass, ExecutionDomain) == 0x000210, "Member 'UOptimusNode_ComputeKernelFunctionGeneratorClass::ExecutionDomain' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ComputeKernelFunctionGeneratorClass, GroupSize) == 0x000218, "Member 'UOptimusNode_ComputeKernelFunctionGeneratorClass::GroupSize' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ComputeKernelFunctionGeneratorClass, InputBindings) == 0x000228, "Member 'UOptimusNode_ComputeKernelFunctionGeneratorClass::InputBindings' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ComputeKernelFunctionGeneratorClass, OutputBindings) == 0x000238, "Member 'UOptimusNode_ComputeKernelFunctionGeneratorClass::OutputBindings' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ComputeKernelFunctionGeneratorClass, ShaderSource) == 0x000248, "Member 'UOptimusNode_ComputeKernelFunctionGeneratorClass::ShaderSource' has a wrong offset!");

// Class OptimusCore.OptimusNode_ComputeKernelFunction
// 0x0000 (0x0118 - 0x0118)
class UOptimusNode_ComputeKernelFunction final : public UOptimusNode_ComputeKernelBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_ComputeKernelFunction">();
	}
	static class UOptimusNode_ComputeKernelFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_ComputeKernelFunction>();
	}
};
static_assert(alignof(UOptimusNode_ComputeKernelFunction) == 0x000008, "Wrong alignment on UOptimusNode_ComputeKernelFunction");
static_assert(sizeof(UOptimusNode_ComputeKernelFunction) == 0x000118, "Wrong size on UOptimusNode_ComputeKernelFunction");

// Class OptimusCore.OptimusNode_ConstantValueGeneratorClass
// 0x0010 (0x0210 - 0x0200)
class UOptimusNode_ConstantValueGeneratorClass final : public UClass
{
public:
	struct FOptimusDataTypeRef                    DataType;                                          // 0x0200(0x0010)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_ConstantValueGeneratorClass">();
	}
	static class UOptimusNode_ConstantValueGeneratorClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_ConstantValueGeneratorClass>();
	}
};
static_assert(alignof(UOptimusNode_ConstantValueGeneratorClass) == 0x000008, "Wrong alignment on UOptimusNode_ConstantValueGeneratorClass");
static_assert(sizeof(UOptimusNode_ConstantValueGeneratorClass) == 0x000210, "Wrong size on UOptimusNode_ConstantValueGeneratorClass");
static_assert(offsetof(UOptimusNode_ConstantValueGeneratorClass, DataType) == 0x000200, "Member 'UOptimusNode_ConstantValueGeneratorClass::DataType' has a wrong offset!");

// Class OptimusCore.OptimusNode_ConstantValue
// 0x0010 (0x0120 - 0x0110)
class UOptimusNode_ConstantValue final : public UOptimusNode
{
public:
	uint8                                         Pad_1A8F[0x10];                                    // 0x0110(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_ConstantValue">();
	}
	static class UOptimusNode_ConstantValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_ConstantValue>();
	}
};
static_assert(alignof(UOptimusNode_ConstantValue) == 0x000008, "Wrong alignment on UOptimusNode_ConstantValue");
static_assert(sizeof(UOptimusNode_ConstantValue) == 0x000120, "Wrong size on UOptimusNode_ConstantValue");

// Class OptimusCore.OptimusNode_CustomComputeKernel
// 0x00D8 (0x01F0 - 0x0118)
class UOptimusNode_CustomComputeKernel final : public UOptimusNode_ComputeKernelBase
{
public:
	uint8                                         Pad_1A90[0x20];                                    // 0x0118(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Category;                                          // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusValidatedName                  KernelName;                                        // 0x0140(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptimusExecutionDomain                ExecutionDomain;                                   // 0x0148(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FIntVector                             GroupSize;                                         // 0x0150(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A91[0x4];                                     // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOptimus_ShaderBinding>         Parameters;                                        // 0x0160(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FOptimusParameterBinding>       InputBindings;                                     // 0x0170(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FOptimusParameterBinding>       OutputBindings;                                    // 0x0180(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	struct FOptimusParameterBindingArray          InputBindingArray;                                 // 0x0190(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FOptimusParameterBindingArray          OutputBindingArray;                                // 0x01A0(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FOptimusSecondaryInputBindingsGroup> SecondaryInputBindingGroups;                       // 0x01B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UComputeSource*>                 AdditionalSources;                                 // 0x01C0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FOptimusShaderText                     ShaderSource;                                      // 0x01D0(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_CustomComputeKernel">();
	}
	static class UOptimusNode_CustomComputeKernel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_CustomComputeKernel>();
	}
};
static_assert(alignof(UOptimusNode_CustomComputeKernel) == 0x000008, "Wrong alignment on UOptimusNode_CustomComputeKernel");
static_assert(sizeof(UOptimusNode_CustomComputeKernel) == 0x0001F0, "Wrong size on UOptimusNode_CustomComputeKernel");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, Category) == 0x000138, "Member 'UOptimusNode_CustomComputeKernel::Category' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, KernelName) == 0x000140, "Member 'UOptimusNode_CustomComputeKernel::KernelName' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, ExecutionDomain) == 0x000148, "Member 'UOptimusNode_CustomComputeKernel::ExecutionDomain' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, GroupSize) == 0x000150, "Member 'UOptimusNode_CustomComputeKernel::GroupSize' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, Parameters) == 0x000160, "Member 'UOptimusNode_CustomComputeKernel::Parameters' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, InputBindings) == 0x000170, "Member 'UOptimusNode_CustomComputeKernel::InputBindings' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, OutputBindings) == 0x000180, "Member 'UOptimusNode_CustomComputeKernel::OutputBindings' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, InputBindingArray) == 0x000190, "Member 'UOptimusNode_CustomComputeKernel::InputBindingArray' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, OutputBindingArray) == 0x0001A0, "Member 'UOptimusNode_CustomComputeKernel::OutputBindingArray' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, SecondaryInputBindingGroups) == 0x0001B0, "Member 'UOptimusNode_CustomComputeKernel::SecondaryInputBindingGroups' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, AdditionalSources) == 0x0001C0, "Member 'UOptimusNode_CustomComputeKernel::AdditionalSources' has a wrong offset!");
static_assert(offsetof(UOptimusNode_CustomComputeKernel, ShaderSource) == 0x0001D0, "Member 'UOptimusNode_CustomComputeKernel::ShaderSource' has a wrong offset!");

// Class OptimusCore.OptimusNode_FunctionReference
// 0x0010 (0x0120 - 0x0110)
class UOptimusNode_FunctionReference final : public UOptimusNode
{
public:
	uint8                                         Pad_1A92[0x8];                                     // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOptimusFunctionNodeGraph*              FunctionGraph;                                     // 0x0118(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_FunctionReference">();
	}
	static class UOptimusNode_FunctionReference* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_FunctionReference>();
	}
};
static_assert(alignof(UOptimusNode_FunctionReference) == 0x000008, "Wrong alignment on UOptimusNode_FunctionReference");
static_assert(sizeof(UOptimusNode_FunctionReference) == 0x000120, "Wrong size on UOptimusNode_FunctionReference");
static_assert(offsetof(UOptimusNode_FunctionReference, FunctionGraph) == 0x000118, "Member 'UOptimusNode_FunctionReference::FunctionGraph' has a wrong offset!");

// Class OptimusCore.OptimusNode_ResourceAccessorBase
// 0x0078 (0x0188 - 0x0110)
class UOptimusNode_ResourceAccessorBase : public UOptimusNode
{
public:
	uint8                                         Pad_1A93[0x10];                                    // 0x0110(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UOptimusResourceDescription> ResourceDesc;                                      // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOptimusBufferWriteType                       WriteType;                                         // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A94[0x7];                                     // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOptimusNode_ResourceAccessorBase_DuplicationInfo DuplicationInfo;                                   // 0x0130(0x0058)(DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_ResourceAccessorBase">();
	}
	static class UOptimusNode_ResourceAccessorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_ResourceAccessorBase>();
	}
};
static_assert(alignof(UOptimusNode_ResourceAccessorBase) == 0x000008, "Wrong alignment on UOptimusNode_ResourceAccessorBase");
static_assert(sizeof(UOptimusNode_ResourceAccessorBase) == 0x000188, "Wrong size on UOptimusNode_ResourceAccessorBase");
static_assert(offsetof(UOptimusNode_ResourceAccessorBase, ResourceDesc) == 0x000120, "Member 'UOptimusNode_ResourceAccessorBase::ResourceDesc' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ResourceAccessorBase, WriteType) == 0x000128, "Member 'UOptimusNode_ResourceAccessorBase::WriteType' has a wrong offset!");
static_assert(offsetof(UOptimusNode_ResourceAccessorBase, DuplicationInfo) == 0x000130, "Member 'UOptimusNode_ResourceAccessorBase::DuplicationInfo' has a wrong offset!");

// Class OptimusCore.OptimusNode_GetResource
// 0x0000 (0x0188 - 0x0188)
class UOptimusNode_GetResource final : public UOptimusNode_ResourceAccessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_GetResource">();
	}
	static class UOptimusNode_GetResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_GetResource>();
	}
};
static_assert(alignof(UOptimusNode_GetResource) == 0x000008, "Wrong alignment on UOptimusNode_GetResource");
static_assert(sizeof(UOptimusNode_GetResource) == 0x000188, "Wrong size on UOptimusNode_GetResource");

// Class OptimusCore.OptimusNode_GetVariable
// 0x0038 (0x0148 - 0x0110)
class UOptimusNode_GetVariable final : public UOptimusNode
{
public:
	uint8                                         Pad_1A95[0x8];                                     // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UOptimusVariableDescription> VariableDesc;                                      // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FOptimusNode_GetVariable_DuplicationInfo DuplicationInfo;                                   // 0x0120(0x0028)(DuplicateTransient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_GetVariable">();
	}
	static class UOptimusNode_GetVariable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_GetVariable>();
	}
};
static_assert(alignof(UOptimusNode_GetVariable) == 0x000008, "Wrong alignment on UOptimusNode_GetVariable");
static_assert(sizeof(UOptimusNode_GetVariable) == 0x000148, "Wrong size on UOptimusNode_GetVariable");
static_assert(offsetof(UOptimusNode_GetVariable, VariableDesc) == 0x000118, "Member 'UOptimusNode_GetVariable::VariableDesc' has a wrong offset!");
static_assert(offsetof(UOptimusNode_GetVariable, DuplicationInfo) == 0x000120, "Member 'UOptimusNode_GetVariable::DuplicationInfo' has a wrong offset!");

// Class OptimusCore.OptimusNode_GraphTerminal
// 0x0018 (0x0128 - 0x0110)
class UOptimusNode_GraphTerminal final : public UOptimusNode
{
public:
	uint8                                         Pad_1A96[0x8];                                     // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EOptimusTerminalType                          TerminalType;                                      // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UOptimusNodeSubGraph>    OwningGraph;                                       // 0x011C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A97[0x4];                                     // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_GraphTerminal">();
	}
	static class UOptimusNode_GraphTerminal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_GraphTerminal>();
	}
};
static_assert(alignof(UOptimusNode_GraphTerminal) == 0x000008, "Wrong alignment on UOptimusNode_GraphTerminal");
static_assert(sizeof(UOptimusNode_GraphTerminal) == 0x000128, "Wrong size on UOptimusNode_GraphTerminal");
static_assert(offsetof(UOptimusNode_GraphTerminal, TerminalType) == 0x000118, "Member 'UOptimusNode_GraphTerminal::TerminalType' has a wrong offset!");
static_assert(offsetof(UOptimusNode_GraphTerminal, OwningGraph) == 0x00011C, "Member 'UOptimusNode_GraphTerminal::OwningGraph' has a wrong offset!");

// Class OptimusCore.OptimusNode_Resource
// 0x0000 (0x0188 - 0x0188)
class UOptimusNode_Resource final : public UOptimusNode_ResourceAccessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_Resource">();
	}
	static class UOptimusNode_Resource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_Resource>();
	}
};
static_assert(alignof(UOptimusNode_Resource) == 0x000008, "Wrong alignment on UOptimusNode_Resource");
static_assert(sizeof(UOptimusNode_Resource) == 0x000188, "Wrong size on UOptimusNode_Resource");

// Class OptimusCore.OptimusNode_SetResource
// 0x0000 (0x0188 - 0x0188)
class UOptimusNode_SetResource final : public UOptimusNode_ResourceAccessorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_SetResource">();
	}
	static class UOptimusNode_SetResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_SetResource>();
	}
};
static_assert(alignof(UOptimusNode_SetResource) == 0x000008, "Wrong alignment on UOptimusNode_SetResource");
static_assert(sizeof(UOptimusNode_SetResource) == 0x000188, "Wrong size on UOptimusNode_SetResource");

// Class OptimusCore.OptimusNode_SubGraphReference
// 0x0010 (0x0120 - 0x0110)
class UOptimusNode_SubGraphReference final : public UOptimusNode
{
public:
	uint8                                         Pad_1A98[0x8];                                     // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOptimusNodeSubGraph*                   SubGraph;                                          // 0x0118(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNode_SubGraphReference">();
	}
	static class UOptimusNode_SubGraphReference* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNode_SubGraphReference>();
	}
};
static_assert(alignof(UOptimusNode_SubGraphReference) == 0x000008, "Wrong alignment on UOptimusNode_SubGraphReference");
static_assert(sizeof(UOptimusNode_SubGraphReference) == 0x000120, "Wrong size on UOptimusNode_SubGraphReference");
static_assert(offsetof(UOptimusNode_SubGraphReference, SubGraph) == 0x000118, "Member 'UOptimusNode_SubGraphReference::SubGraph' has a wrong offset!");

// Class OptimusCore.OptimusActionStack
// 0x00B8 (0x00E0 - 0x0028)
class UOptimusActionStack final : public UObject
{
public:
	int32                                         TransactedActionIndex;                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A99[0xB4];                                    // 0x002C(0x00B4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusActionStack">();
	}
	static class UOptimusActionStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusActionStack>();
	}
};
static_assert(alignof(UOptimusActionStack) == 0x000008, "Wrong alignment on UOptimusActionStack");
static_assert(sizeof(UOptimusActionStack) == 0x0000E0, "Wrong size on UOptimusActionStack");
static_assert(offsetof(UOptimusActionStack, TransactedActionIndex) == 0x000028, "Member 'UOptimusActionStack::TransactedActionIndex' has a wrong offset!");

// Class OptimusCore.OptimusComponentSourceBinding
// 0x0028 (0x0050 - 0x0028)
class UOptimusComponentSourceBinding final : public UObject
{
public:
	class FName                                   BindingName;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOptimusComponentSource>    ComponentType;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ComponentTags;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsPrimaryBinding;                                 // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9A[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusComponentSourceBinding">();
	}
	static class UOptimusComponentSourceBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusComponentSourceBinding>();
	}
};
static_assert(alignof(UOptimusComponentSourceBinding) == 0x000008, "Wrong alignment on UOptimusComponentSourceBinding");
static_assert(sizeof(UOptimusComponentSourceBinding) == 0x000050, "Wrong size on UOptimusComponentSourceBinding");
static_assert(offsetof(UOptimusComponentSourceBinding, BindingName) == 0x000028, "Member 'UOptimusComponentSourceBinding::BindingName' has a wrong offset!");
static_assert(offsetof(UOptimusComponentSourceBinding, ComponentType) == 0x000030, "Member 'UOptimusComponentSourceBinding::ComponentType' has a wrong offset!");
static_assert(offsetof(UOptimusComponentSourceBinding, ComponentTags) == 0x000038, "Member 'UOptimusComponentSourceBinding::ComponentTags' has a wrong offset!");
static_assert(offsetof(UOptimusComponentSourceBinding, bIsPrimaryBinding) == 0x000048, "Member 'UOptimusComponentSourceBinding::bIsPrimaryBinding' has a wrong offset!");

// Class OptimusCore.OptimusComputeGraph
// 0x0010 (0x00A0 - 0x0090)
class UOptimusComputeGraph final : public UComputeGraph
{
public:
	TArray<TWeakObjectPtr<class UOptimusNode>>    KernelToNode;                                      // 0x0090(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusComputeGraph">();
	}
	static class UOptimusComputeGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusComputeGraph>();
	}
};
static_assert(alignof(UOptimusComputeGraph) == 0x000008, "Wrong alignment on UOptimusComputeGraph");
static_assert(sizeof(UOptimusComputeGraph) == 0x0000A0, "Wrong size on UOptimusComputeGraph");
static_assert(offsetof(UOptimusComputeGraph, KernelToNode) == 0x000090, "Member 'UOptimusComputeGraph::KernelToNode' has a wrong offset!");

// Class OptimusCore.OptimusComponentSourceBindingContainer
// 0x0010 (0x0038 - 0x0028)
class UOptimusComponentSourceBindingContainer final : public UObject
{
public:
	TArray<class UOptimusComponentSourceBinding*> Bindings;                                          // 0x0028(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusComponentSourceBindingContainer">();
	}
	static class UOptimusComponentSourceBindingContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusComponentSourceBindingContainer>();
	}
};
static_assert(alignof(UOptimusComponentSourceBindingContainer) == 0x000008, "Wrong alignment on UOptimusComponentSourceBindingContainer");
static_assert(sizeof(UOptimusComponentSourceBindingContainer) == 0x000038, "Wrong size on UOptimusComponentSourceBindingContainer");
static_assert(offsetof(UOptimusComponentSourceBindingContainer, Bindings) == 0x000028, "Member 'UOptimusComponentSourceBindingContainer::Bindings' has a wrong offset!");

// Class OptimusCore.OptimusVariableContainer
// 0x0010 (0x0038 - 0x0028)
class UOptimusVariableContainer final : public UObject
{
public:
	TArray<class UOptimusVariableDescription*>    Descriptions;                                      // 0x0028(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusVariableContainer">();
	}
	static class UOptimusVariableContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusVariableContainer>();
	}
};
static_assert(alignof(UOptimusVariableContainer) == 0x000008, "Wrong alignment on UOptimusVariableContainer");
static_assert(sizeof(UOptimusVariableContainer) == 0x000038, "Wrong size on UOptimusVariableContainer");
static_assert(offsetof(UOptimusVariableContainer, Descriptions) == 0x000028, "Member 'UOptimusVariableContainer::Descriptions' has a wrong offset!");

// Class OptimusCore.OptimusResourceContainer
// 0x0010 (0x0038 - 0x0028)
class UOptimusResourceContainer final : public UObject
{
public:
	TArray<class UOptimusResourceDescription*>    Descriptions;                                      // 0x0028(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusResourceContainer">();
	}
	static class UOptimusResourceContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusResourceContainer>();
	}
};
static_assert(alignof(UOptimusResourceContainer) == 0x000008, "Wrong alignment on UOptimusResourceContainer");
static_assert(sizeof(UOptimusResourceContainer) == 0x000038, "Wrong size on UOptimusResourceContainer");
static_assert(offsetof(UOptimusResourceContainer, Descriptions) == 0x000028, "Member 'UOptimusResourceContainer::Descriptions' has a wrong offset!");

// Class OptimusCore.OptimusDeformer
// 0x0100 (0x0128 - 0x0028)
class UOptimusDeformer final : public UMeshDeformer
{
public:
	uint8                                         Pad_1A9B[0x20];                                    // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          Mesh;                                              // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOptimusComputeGraphInfo>       ComputeGraphs;                                     // 0x0050(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UOptimusActionStack*                    ActionStack;                                       // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOptimusDeformerStatus                        Status;                                            // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A9C[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOptimusNodeGraph*>              Graphs;                                            // 0x0070(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UOptimusComponentSourceBindingContainer* Bindings;                                          // 0x0080(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOptimusVariableContainer*              Variables;                                         // 0x0088(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOptimusResourceContainer*              Resources;                                         // 0x0090(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A9D[0x90];                                    // 0x0098(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const TArray<class UOptimusComponentSourceBinding*> GetComponentBindings() const;
	const TArray<class UOptimusResourceDescription*> GetResources() const;
	const TArray<class UOptimusVariableDescription*> GetVariables() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDeformer">();
	}
	static class UOptimusDeformer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusDeformer>();
	}
};
static_assert(alignof(UOptimusDeformer) == 0x000008, "Wrong alignment on UOptimusDeformer");
static_assert(sizeof(UOptimusDeformer) == 0x000128, "Wrong size on UOptimusDeformer");
static_assert(offsetof(UOptimusDeformer, Mesh) == 0x000048, "Member 'UOptimusDeformer::Mesh' has a wrong offset!");
static_assert(offsetof(UOptimusDeformer, ComputeGraphs) == 0x000050, "Member 'UOptimusDeformer::ComputeGraphs' has a wrong offset!");
static_assert(offsetof(UOptimusDeformer, ActionStack) == 0x000060, "Member 'UOptimusDeformer::ActionStack' has a wrong offset!");
static_assert(offsetof(UOptimusDeformer, Status) == 0x000068, "Member 'UOptimusDeformer::Status' has a wrong offset!");
static_assert(offsetof(UOptimusDeformer, Graphs) == 0x000070, "Member 'UOptimusDeformer::Graphs' has a wrong offset!");
static_assert(offsetof(UOptimusDeformer, Bindings) == 0x000080, "Member 'UOptimusDeformer::Bindings' has a wrong offset!");
static_assert(offsetof(UOptimusDeformer, Variables) == 0x000088, "Member 'UOptimusDeformer::Variables' has a wrong offset!");
static_assert(offsetof(UOptimusDeformer, Resources) == 0x000090, "Member 'UOptimusDeformer::Resources' has a wrong offset!");

// Class OptimusCore.OptimusDeformerInstanceSettings
// 0x0018 (0x0040 - 0x0028)
class UOptimusDeformerInstanceSettings final : public UMeshDeformerInstanceSettings
{
public:
	TWeakObjectPtr<class UOptimusDeformer>        Deformer;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FOptimusDeformerInstanceComponentBinding> Bindings;                                          // 0x0030(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDeformerInstanceSettings">();
	}
	static class UOptimusDeformerInstanceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusDeformerInstanceSettings>();
	}
};
static_assert(alignof(UOptimusDeformerInstanceSettings) == 0x000008, "Wrong alignment on UOptimusDeformerInstanceSettings");
static_assert(sizeof(UOptimusDeformerInstanceSettings) == 0x000040, "Wrong size on UOptimusDeformerInstanceSettings");
static_assert(offsetof(UOptimusDeformerInstanceSettings, Deformer) == 0x000028, "Member 'UOptimusDeformerInstanceSettings::Deformer' has a wrong offset!");
static_assert(offsetof(UOptimusDeformerInstanceSettings, Bindings) == 0x000030, "Member 'UOptimusDeformerInstanceSettings::Bindings' has a wrong offset!");

// Class OptimusCore.OptimusDeformerInstance
// 0x00B8 (0x00E0 - 0x0028)
class UOptimusDeformerInstance final : public UMeshDeformerInstance
{
public:
	TWeakObjectPtr<class UMeshComponent>          MeshComponent;                                     // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UOptimusDeformerInstanceSettings> InstanceSettings;                                  // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FOptimusDeformerInstanceExecInfo> ComputeGraphExecInfos;                             // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UOptimusVariableContainer*              Variables;                                         // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A9E[0x90];                                    // 0x0050(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool EnqueueTriggerGraph(class FName InTriggerGraphName);
	bool SetBoolVariable(class FName InVariableName, bool InValue);
	bool SetFloatVariable(class FName InVariableName, double InValue);
	bool SetIntVariable(class FName InVariableName, int32 InValue);
	bool SetTransformVariable(class FName InVariableName, const struct FTransform& InValue);
	bool SetVector4Variable(class FName InVariableName, const struct FVector4& InValue);
	bool SetVectorVariable(class FName InVariableName, const struct FVector& InValue);

	const TArray<class UOptimusVariableDescription*> GetVariables() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusDeformerInstance">();
	}
	static class UOptimusDeformerInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusDeformerInstance>();
	}
};
static_assert(alignof(UOptimusDeformerInstance) == 0x000008, "Wrong alignment on UOptimusDeformerInstance");
static_assert(sizeof(UOptimusDeformerInstance) == 0x0000E0, "Wrong size on UOptimusDeformerInstance");
static_assert(offsetof(UOptimusDeformerInstance, MeshComponent) == 0x000028, "Member 'UOptimusDeformerInstance::MeshComponent' has a wrong offset!");
static_assert(offsetof(UOptimusDeformerInstance, InstanceSettings) == 0x000030, "Member 'UOptimusDeformerInstance::InstanceSettings' has a wrong offset!");
static_assert(offsetof(UOptimusDeformerInstance, ComputeGraphExecInfos) == 0x000038, "Member 'UOptimusDeformerInstance::ComputeGraphExecInfos' has a wrong offset!");
static_assert(offsetof(UOptimusDeformerInstance, Variables) == 0x000048, "Member 'UOptimusDeformerInstance::Variables' has a wrong offset!");

// Class OptimusCore.OptimusNodeGraph
// 0x0058 (0x0080 - 0x0028)
class UOptimusNodeGraph : public UObject
{
public:
	uint8                                         Pad_1AA8[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EOptimusNodeGraphType                         GraphType;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AA9[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOptimusNode*>                   Nodes;                                             // 0x0038(0x0010)(ZeroConstructor, NonTransactional, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UOptimusNodeLink*>               Links;                                             // 0x0048(0x0010)(ZeroConstructor, NonTransactional, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UOptimusNodeGraph*>              Subgraphs;                                         // 0x0058(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AAA[0x18];                                    // 0x0068(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UOptimusNode* AddComponentBindingGetNode(class UOptimusComponentSourceBinding* InComponentBinding, const struct FVector2D& InPosition);
	class UOptimusNode* AddDataInterfaceNode(const TSubclassOf<class UOptimusComputeDataInterface> InDataInterfaceClass, const struct FVector2D& InPosition);
	bool AddLink(class UOptimusNodePin* InNodeOutputPin, class UOptimusNodePin* InNodeInputPin);
	class UOptimusNode* AddNode(const TSubclassOf<class UOptimusNode> InNodeClass, const struct FVector2D& InPosition);
	class UOptimusNode* AddResourceGetNode(class UOptimusResourceDescription* InResourceDesc, const struct FVector2D& InPosition);
	class UOptimusNode* AddResourceNode(class UOptimusResourceDescription* InResourceDesc, const struct FVector2D& InPosition);
	class UOptimusNode* AddResourceSetNode(class UOptimusResourceDescription* InResourceDesc, const struct FVector2D& InPosition);
	class UOptimusNode* AddValueNode(const struct FOptimusDataTypeRef& InDataTypeRef, const struct FVector2D& InPosition);
	class UOptimusNode* AddVariableGetNode(class UOptimusVariableDescription* InVariableDesc, const struct FVector2D& InPosition);
	class UOptimusNode* CollapseNodesToFunction(const TArray<class UOptimusNode*>& InNodes);
	class UOptimusNode* CollapseNodesToSubGraph(const TArray<class UOptimusNode*>& InNodes);
	class UOptimusNode* ConvertCustomKernelToFunction(class UOptimusNode* InCustomKernel);
	class UOptimusNode* ConvertFunctionToCustomKernel(class UOptimusNode* InKernelFunction);
	class UOptimusNode* DuplicateNode(class UOptimusNode* InNode, const struct FVector2D& InPosition);
	bool DuplicateNodes(const TArray<class UOptimusNode*>& InNodes, const struct FVector2D& InPosition);
	TArray<class UOptimusNode*> ExpandCollapsedNodes(class UOptimusNode* InFunctionNode);
	bool MoveGraph(class UOptimusNodeGraph* InGraph, int32 InInsertBefore);
	bool RemoveAllLinks(class UOptimusNodePin* InNodePin);
	bool RemoveLink(class UOptimusNodePin* InNodeOutputPin, class UOptimusNodePin* InNodeInputPin);
	bool RemoveNode(class UOptimusNode* InNode);
	bool RemoveNodes(const TArray<class UOptimusNode*>& InNodes);
	bool RenameGraph(class UOptimusNodeGraph* InGraph, const class FString& InNewName);

	int32 GetGraphIndex() const;
	const TArray<class UOptimusNodeGraph*> GetGraphs() const;
	EOptimusNodeGraphType GetGraphType() const;
	bool IsCustomKernel(class UOptimusNode* InNode) const;
	bool IsExecutionGraph() const;
	bool IsFunctionGraph() const;
	bool IsFunctionReference(class UOptimusNode* InNode) const;
	bool IsKernelFunction(class UOptimusNode* InNode) const;
	bool IsSubGraphReference(class UOptimusNode* InNode) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodeGraph">();
	}
	static class UOptimusNodeGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNodeGraph>();
	}
};
static_assert(alignof(UOptimusNodeGraph) == 0x000008, "Wrong alignment on UOptimusNodeGraph");
static_assert(sizeof(UOptimusNodeGraph) == 0x000080, "Wrong size on UOptimusNodeGraph");
static_assert(offsetof(UOptimusNodeGraph, GraphType) == 0x000030, "Member 'UOptimusNodeGraph::GraphType' has a wrong offset!");
static_assert(offsetof(UOptimusNodeGraph, Nodes) == 0x000038, "Member 'UOptimusNodeGraph::Nodes' has a wrong offset!");
static_assert(offsetof(UOptimusNodeGraph, Links) == 0x000048, "Member 'UOptimusNodeGraph::Links' has a wrong offset!");
static_assert(offsetof(UOptimusNodeGraph, Subgraphs) == 0x000058, "Member 'UOptimusNodeGraph::Subgraphs' has a wrong offset!");

// Class OptimusCore.OptimusNodeSubGraph
// 0x0030 (0x00B0 - 0x0080)
class UOptimusNodeSubGraph : public UOptimusNodeGraph
{
public:
	TArray<struct FOptimusParameterBinding>       InputBindings;                                     // 0x0080(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FOptimusParameterBinding>       OutputBindings;                                    // 0x0090(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UOptimusNode_GraphTerminal> EntryNode;                                         // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UOptimusNode_GraphTerminal> ReturnNode;                                        // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodeSubGraph">();
	}
	static class UOptimusNodeSubGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNodeSubGraph>();
	}
};
static_assert(alignof(UOptimusNodeSubGraph) == 0x000008, "Wrong alignment on UOptimusNodeSubGraph");
static_assert(sizeof(UOptimusNodeSubGraph) == 0x0000B0, "Wrong size on UOptimusNodeSubGraph");
static_assert(offsetof(UOptimusNodeSubGraph, InputBindings) == 0x000080, "Member 'UOptimusNodeSubGraph::InputBindings' has a wrong offset!");
static_assert(offsetof(UOptimusNodeSubGraph, OutputBindings) == 0x000090, "Member 'UOptimusNodeSubGraph::OutputBindings' has a wrong offset!");
static_assert(offsetof(UOptimusNodeSubGraph, EntryNode) == 0x0000A0, "Member 'UOptimusNodeSubGraph::EntryNode' has a wrong offset!");
static_assert(offsetof(UOptimusNodeSubGraph, ReturnNode) == 0x0000A8, "Member 'UOptimusNodeSubGraph::ReturnNode' has a wrong offset!");

// Class OptimusCore.OptimusFunctionNodeGraph
// 0x0008 (0x00B8 - 0x00B0)
class UOptimusFunctionNodeGraph final : public UOptimusNodeSubGraph
{
public:
	class FName                                   Category;                                          // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusFunctionNodeGraph">();
	}
	static class UOptimusFunctionNodeGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusFunctionNodeGraph>();
	}
};
static_assert(alignof(UOptimusFunctionNodeGraph) == 0x000008, "Wrong alignment on UOptimusFunctionNodeGraph");
static_assert(sizeof(UOptimusFunctionNodeGraph) == 0x0000B8, "Wrong size on UOptimusFunctionNodeGraph");
static_assert(offsetof(UOptimusFunctionNodeGraph, Category) == 0x0000B0, "Member 'UOptimusFunctionNodeGraph::Category' has a wrong offset!");

// Class OptimusCore.OptimusNodeLink
// 0x0010 (0x0038 - 0x0028)
class UOptimusNodeLink final : public UObject
{
public:
	class UOptimusNodePin*                        NodeOutputPin;                                     // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOptimusNodePin*                        NodeInputPin;                                      // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodeLink">();
	}
	static class UOptimusNodeLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNodeLink>();
	}
};
static_assert(alignof(UOptimusNodeLink) == 0x000008, "Wrong alignment on UOptimusNodeLink");
static_assert(sizeof(UOptimusNodeLink) == 0x000038, "Wrong size on UOptimusNodeLink");
static_assert(offsetof(UOptimusNodeLink, NodeOutputPin) == 0x000028, "Member 'UOptimusNodeLink::NodeOutputPin' has a wrong offset!");
static_assert(offsetof(UOptimusNodeLink, NodeInputPin) == 0x000030, "Member 'UOptimusNodeLink::NodeInputPin' has a wrong offset!");

// Class OptimusCore.OptimusNodePin
// 0x0068 (0x0090 - 0x0028)
class UOptimusNodePin final : public UObject
{
public:
	bool                                          bIsGroupingPin;                                    // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOptimusNodePinDirection                      Direction;                                         // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOptimusNodePinStorageType                    StorageType;                                       // 0x002A(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AB7[0x5];                                     // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOptimusDataDomain                     DataDomain;                                        // 0x0030(0x0040)(NativeAccessSpecifierPrivate)
	struct FOptimusDataTypeRef                    DataType;                                          // 0x0070(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	TArray<class UOptimusNodePin*>                SubPins;                                           // 0x0080(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusNodePin">();
	}
	static class UOptimusNodePin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusNodePin>();
	}
};
static_assert(alignof(UOptimusNodePin) == 0x000008, "Wrong alignment on UOptimusNodePin");
static_assert(sizeof(UOptimusNodePin) == 0x000090, "Wrong size on UOptimusNodePin");
static_assert(offsetof(UOptimusNodePin, bIsGroupingPin) == 0x000028, "Member 'UOptimusNodePin::bIsGroupingPin' has a wrong offset!");
static_assert(offsetof(UOptimusNodePin, Direction) == 0x000029, "Member 'UOptimusNodePin::Direction' has a wrong offset!");
static_assert(offsetof(UOptimusNodePin, StorageType) == 0x00002A, "Member 'UOptimusNodePin::StorageType' has a wrong offset!");
static_assert(offsetof(UOptimusNodePin, DataDomain) == 0x000030, "Member 'UOptimusNodePin::DataDomain' has a wrong offset!");
static_assert(offsetof(UOptimusNodePin, DataType) == 0x000070, "Member 'UOptimusNodePin::DataType' has a wrong offset!");
static_assert(offsetof(UOptimusNodePin, SubPins) == 0x000080, "Member 'UOptimusNodePin::SubPins' has a wrong offset!");

// Class OptimusCore.OptimusResourceDescription
// 0x0068 (0x0090 - 0x0028)
class UOptimusResourceDescription final : public UObject
{
public:
	class FName                                   ResourceName;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusDataTypeRef                    DataType;                                          // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UOptimusComponentSourceBinding> ComponentBinding;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusDataDomain                     DataDomain;                                        // 0x0048(0x0040)(Edit, NativeAccessSpecifierPublic)
	class UOptimusPersistentBufferDataInterface*  DataInterface;                                     // 0x0088(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusResourceDescription">();
	}
	static class UOptimusResourceDescription* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusResourceDescription>();
	}
};
static_assert(alignof(UOptimusResourceDescription) == 0x000008, "Wrong alignment on UOptimusResourceDescription");
static_assert(sizeof(UOptimusResourceDescription) == 0x000090, "Wrong size on UOptimusResourceDescription");
static_assert(offsetof(UOptimusResourceDescription, ResourceName) == 0x000028, "Member 'UOptimusResourceDescription::ResourceName' has a wrong offset!");
static_assert(offsetof(UOptimusResourceDescription, DataType) == 0x000030, "Member 'UOptimusResourceDescription::DataType' has a wrong offset!");
static_assert(offsetof(UOptimusResourceDescription, ComponentBinding) == 0x000040, "Member 'UOptimusResourceDescription::ComponentBinding' has a wrong offset!");
static_assert(offsetof(UOptimusResourceDescription, DataDomain) == 0x000048, "Member 'UOptimusResourceDescription::DataDomain' has a wrong offset!");
static_assert(offsetof(UOptimusResourceDescription, DataInterface) == 0x000088, "Member 'UOptimusResourceDescription::DataInterface' has a wrong offset!");

// Class OptimusCore.OptimusSource
// 0x0018 (0x0050 - 0x0038)
class UOptimusSource final : public UComputeSource
{
public:
	uint8                                         Pad_1AB8[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SourceText;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusSource">();
	}
	static class UOptimusSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusSource>();
	}
};
static_assert(alignof(UOptimusSource) == 0x000008, "Wrong alignment on UOptimusSource");
static_assert(sizeof(UOptimusSource) == 0x000050, "Wrong size on UOptimusSource");
static_assert(offsetof(UOptimusSource, SourceText) == 0x000040, "Member 'UOptimusSource::SourceText' has a wrong offset!");

// Class OptimusCore.OptimusValueContainerGeneratorClass
// 0x0010 (0x0210 - 0x0200)
class UOptimusValueContainerGeneratorClass final : public UClass
{
public:
	struct FOptimusDataTypeRef                    DataType;                                          // 0x0200(0x0010)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusValueContainerGeneratorClass">();
	}
	static class UOptimusValueContainerGeneratorClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusValueContainerGeneratorClass>();
	}
};
static_assert(alignof(UOptimusValueContainerGeneratorClass) == 0x000008, "Wrong alignment on UOptimusValueContainerGeneratorClass");
static_assert(sizeof(UOptimusValueContainerGeneratorClass) == 0x000210, "Wrong size on UOptimusValueContainerGeneratorClass");
static_assert(offsetof(UOptimusValueContainerGeneratorClass, DataType) == 0x000200, "Member 'UOptimusValueContainerGeneratorClass::DataType' has a wrong offset!");

// Class OptimusCore.OptimusValueContainer
// 0x0000 (0x0028 - 0x0028)
class UOptimusValueContainer final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusValueContainer">();
	}
	static class UOptimusValueContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusValueContainer>();
	}
};
static_assert(alignof(UOptimusValueContainer) == 0x000008, "Wrong alignment on UOptimusValueContainer");
static_assert(sizeof(UOptimusValueContainer) == 0x000028, "Wrong size on UOptimusValueContainer");

// Class OptimusCore.OptimusVariableDescription
// 0x0040 (0x0068 - 0x0028)
class UOptimusVariableDescription final : public UObject
{
public:
	struct FGuid                                  Guid;                                              // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VariableName;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOptimusDataTypeRef                    DataType;                                          // 0x0040(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UOptimusValueContainer*                 DefaultValue;                                      // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 ValueData;                                         // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimusVariableDescription">();
	}
	static class UOptimusVariableDescription* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimusVariableDescription>();
	}
};
static_assert(alignof(UOptimusVariableDescription) == 0x000008, "Wrong alignment on UOptimusVariableDescription");
static_assert(sizeof(UOptimusVariableDescription) == 0x000068, "Wrong size on UOptimusVariableDescription");
static_assert(offsetof(UOptimusVariableDescription, Guid) == 0x000028, "Member 'UOptimusVariableDescription::Guid' has a wrong offset!");
static_assert(offsetof(UOptimusVariableDescription, VariableName) == 0x000038, "Member 'UOptimusVariableDescription::VariableName' has a wrong offset!");
static_assert(offsetof(UOptimusVariableDescription, DataType) == 0x000040, "Member 'UOptimusVariableDescription::DataType' has a wrong offset!");
static_assert(offsetof(UOptimusVariableDescription, DefaultValue) == 0x000050, "Member 'UOptimusVariableDescription::DefaultValue' has a wrong offset!");
static_assert(offsetof(UOptimusVariableDescription, ValueData) == 0x000058, "Member 'UOptimusVariableDescription::ValueData' has a wrong offset!");

}

